{"version":3,"sources":["../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/clone.js","../node_modules/.pnpm/dagre-d3-es@7.0.10/node_modules/dagre-d3-es/src/graphlib/json.js","../node_modules/.pnpm/mermaid@10.6.0/node_modules/mermaid/dist/index-2c4b9a3b.js","../node_modules/.pnpm/mermaid@10.6.0/node_modules/mermaid/dist/classDiagram-v2-c3cb15f1.js"],"names":["CLONE_SYMBOLS_FLAG","lodash_es_clone","value","Object","_baseClone","write","g","json","options","directed","isDirected","multigraph","isMultigraph","compound","isCompound","nodes","writeNodes","edges","writeEdges","isUndefined","graph","map","v","nodeValue","node","parent","e","edgeValue","edge","w","name","__webpack_require__","d","__webpack_exports__","render","dagre_d3_es_src_dagre_index_js__WEBPACK_IMPORTED_MODULE_0__","dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__","_edges_f2ad444c_js__WEBPACK_IMPORTED_MODULE_2__","_mermaid_8af3addd_js__WEBPACK_IMPORTED_MODULE_3__","dagre_d3_es_src_graphlib_index_js__WEBPACK_IMPORTED_MODULE_4__","_createText_62fc7601_js__WEBPACK_IMPORTED_MODULE_5__","d3__WEBPACK_IMPORTED_MODULE_6__","clusterDb","descendants","parents","isDescendant","id","ancenstorId","trace","includes","copy","clusterId","newGraph","rootId","warn","children","push","forEach","length","data","info","setNode","setParent","debug","data2","edgeInCluster","setEdge","error","removeNode","extractDescendants","res","child","findNonClusterChild","_id","getAnchorId","externalConnections","extractor","depth","hasChildren","dir","rankdir","clusterData","clusterGraph","setGraph","nodesep","ranksep","marginx","marginy","setDefaultEdgeLabel","clusterNode","labelText","sorter","result","assign","sorted","shapes","rect","shapeSvg","insert","attr","class","rect2","useHtmlLabels","flowchart","htmlLabels","label","text","labelType","style","labelStyle","appendChild","bbox","getBBox","div","dv","getBoundingClientRect","width","height","padding","halfPadding","diff","JSON","stringify","rx","ry","x","y","rectBox","intersect","point","roundedWithTitle","classes","innerRect","append","noteGroup","divider","clusterElems","recursiveRender","async","_elem","diagramtype","parentCluster","elem","clusters","edgePaths","edgeLabels","Promise","all","parse","o","newEl","sortNodesByHierarchy","shape","insertCluster","paths","n","type","markers","removeEdge","specialId","domId","edge1","structuredClone","edge2","arrowTypeEnd","fromCluster","toCluster","adjustClustersAndEdges","r","diagram","_styles_3dcbcfbf_js__WEBPACK_IMPORTED_MODULE_0__","d3__WEBPACK_IMPORTED_MODULE_1__","dagre_d3_es_src_graphlib_index_js__WEBPACK_IMPORTED_MODULE_2__","_index_2c4b9a3b_js__WEBPACK_IMPORTED_MODULE_4__","sanitizeText","txt","conf","dividerMargin","textHeight","curve","addClasses","diagObj","keys","filter","_vertex$label","_ref2","_a","_b","vertex","cssClassStr","cssClasses","join","styles2","vertexText","classData","tooltip","db","getTooltip","haveCallback","link","getArrowMarker","marker","renderer","setConf","cnf","draw","_version","_getConfig$flowchart","_ref5","_ref6","_ref7","conf2","securityLevel","nodeSpacing","rankSpacing","getDirection","namespaces","getNamespaces","getClasses","relations","getRelations","notes","getNotes","sandboxElement","_ref","addNamespaces","cnt","edgeData","pattern","relation","lineType","arrowhead","startLabelRight","relationTitle1","endLabelLeft","relationTitle2","arrowTypeStart","type1","type2","_ref4","title","arrowheadStyle","labelpos","replace","lineBreakRegex","id1","id2","addRelations","startEdgeId","note","i","_ref3","noteData","edgeId","concat","addNotes","root","contentDocument","body","svg","select","element","insertTitle","titleTopMargin","getDiagramTitle","diagramPadding","useMaxWidth","doc","document","labels","querySelectorAll","dim","createElementNS","setAttribute","insertBefore","firstChild","parser","styles","init","arrowMarkerAbsolute","clear"],"mappings":"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","file":"static/js/13.092759b4.chunk.js","sourcesContent":["import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\nexport default clone;","import * as _ from 'lodash-es';\nimport { Graph } from './graph.js';\nexport { write, read };\nfunction write(g) {\n  var json = {\n    options: {\n      directed: g.isDirected(),\n      multigraph: g.isMultigraph(),\n      compound: g.isCompound()\n    },\n    nodes: writeNodes(g),\n    edges: writeEdges(g)\n  };\n  if (!_.isUndefined(g.graph())) {\n    json.value = _.clone(g.graph());\n  }\n  return json;\n}\nfunction writeNodes(g) {\n  return _.map(g.nodes(), function (v) {\n    var nodeValue = g.node(v);\n    var parent = g.parent(v);\n    var node = {\n      v: v\n    };\n    if (!_.isUndefined(nodeValue)) {\n      node.value = nodeValue;\n    }\n    if (!_.isUndefined(parent)) {\n      node.parent = parent;\n    }\n    return node;\n  });\n}\nfunction writeEdges(g) {\n  return _.map(g.edges(), function (e) {\n    var edgeValue = g.edge(e);\n    var edge = {\n      v: e.v,\n      w: e.w\n    };\n    if (!_.isUndefined(e.name)) {\n      edge.name = e.name;\n    }\n    if (!_.isUndefined(edgeValue)) {\n      edge.value = edgeValue;\n    }\n    return edge;\n  });\n}\nfunction read(json) {\n  var g = new Graph(json.options).setGraph(json.value);\n  _.each(json.nodes, function (entry) {\n    g.setNode(entry.v, entry.value);\n    if (entry.parent) {\n      g.setParent(entry.v, entry.parent);\n    }\n  });\n  _.each(json.edges, function (entry) {\n    g.setEdge({\n      v: entry.v,\n      w: entry.w,\n      name: entry.name\n    }, entry.value);\n  });\n  return g;\n}","import { layout } from \"dagre-d3-es/src/dagre/index.js\";\nimport * as graphlibJson from \"dagre-d3-es/src/graphlib/json.js\";\nimport { c as createLabel, i as intersectRect, a as insertMarkers, b as clear$2, d as clear$3, u as updateNodeBounds, s as setNodeElem, e as insertNode, f as insertEdgeLabel, p as positionNode, g as insertEdge, h as positionEdgeLabel } from \"./edges-f2ad444c.js\";\nimport { l as log, m as evaluate, c as getConfig } from \"./mermaid-8af3addd.js\";\nimport * as graphlib from \"dagre-d3-es/src/graphlib/index.js\";\nimport { a as createText } from \"./createText-62fc7601.js\";\nimport { select } from \"d3\";\nlet clusterDb = {};\nlet descendants = {};\nlet parents = {};\nconst clear$1 = () => {\n  descendants = {};\n  parents = {};\n  clusterDb = {};\n};\nconst isDescendant = (id, ancenstorId) => {\n  log.trace(\"In isDecendant\", ancenstorId, \" \", id, \" = \", descendants[ancenstorId].includes(id));\n  if (descendants[ancenstorId].includes(id)) {\n    return true;\n  }\n  return false;\n};\nconst edgeInCluster = (edge, clusterId) => {\n  log.info(\"Decendants of \", clusterId, \" is \", descendants[clusterId]);\n  log.info(\"Edge is \", edge);\n  if (edge.v === clusterId) {\n    return false;\n  }\n  if (edge.w === clusterId) {\n    return false;\n  }\n  if (!descendants[clusterId]) {\n    log.debug(\"Tilt, \", clusterId, \",not in decendants\");\n    return false;\n  }\n  return descendants[clusterId].includes(edge.v) || isDescendant(edge.v, clusterId) || isDescendant(edge.w, clusterId) || descendants[clusterId].includes(edge.w);\n};\nconst copy = (clusterId, graph, newGraph, rootId) => {\n  log.warn(\"Copying children of \", clusterId, \"root\", rootId, \"data\", graph.node(clusterId), rootId);\n  const nodes = graph.children(clusterId) || [];\n  if (clusterId !== rootId) {\n    nodes.push(clusterId);\n  }\n  log.warn(\"Copying (nodes) clusterId\", clusterId, \"nodes\", nodes);\n  nodes.forEach(node => {\n    if (graph.children(node).length > 0) {\n      copy(node, graph, newGraph, rootId);\n    } else {\n      const data = graph.node(node);\n      log.info(\"cp \", node, \" to \", rootId, \" with parent \", clusterId);\n      newGraph.setNode(node, data);\n      if (rootId !== graph.parent(node)) {\n        log.warn(\"Setting parent\", node, graph.parent(node));\n        newGraph.setParent(node, graph.parent(node));\n      }\n      if (clusterId !== rootId && node !== clusterId) {\n        log.debug(\"Setting parent\", node, clusterId);\n        newGraph.setParent(node, clusterId);\n      } else {\n        log.info(\"In copy \", clusterId, \"root\", rootId, \"data\", graph.node(clusterId), rootId);\n        log.debug(\"Not Setting parent for node=\", node, \"cluster!==rootId\", clusterId !== rootId, \"node!==clusterId\", node !== clusterId);\n      }\n      const edges = graph.edges(node);\n      log.debug(\"Copying Edges\", edges);\n      edges.forEach(edge => {\n        log.info(\"Edge\", edge);\n        const data2 = graph.edge(edge.v, edge.w, edge.name);\n        log.info(\"Edge data\", data2, rootId);\n        try {\n          if (edgeInCluster(edge, rootId)) {\n            log.info(\"Copying as \", edge.v, edge.w, data2, edge.name);\n            newGraph.setEdge(edge.v, edge.w, data2, edge.name);\n            log.info(\"newGraph edges \", newGraph.edges(), newGraph.edge(newGraph.edges()[0]));\n          } else {\n            log.info(\"Skipping copy of edge \", edge.v, \"-->\", edge.w, \" rootId: \", rootId, \" clusterId:\", clusterId);\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      });\n    }\n    log.debug(\"Removing node\", node);\n    graph.removeNode(node);\n  });\n};\nconst extractDescendants = (id, graph) => {\n  const children = graph.children(id);\n  let res = [...children];\n  for (const child of children) {\n    parents[child] = id;\n    res = [...res, ...extractDescendants(child, graph)];\n  }\n  return res;\n};\nconst findNonClusterChild = (id, graph) => {\n  log.trace(\"Searching\", id);\n  const children = graph.children(id);\n  log.trace(\"Searching children of id \", id, children);\n  if (children.length < 1) {\n    log.trace(\"This is a valid node\", id);\n    return id;\n  }\n  for (const child of children) {\n    const _id = findNonClusterChild(child, graph);\n    if (_id) {\n      log.trace(\"Found replacement for\", id, \" => \", _id);\n      return _id;\n    }\n  }\n};\nconst getAnchorId = id => {\n  if (!clusterDb[id]) {\n    return id;\n  }\n  if (!clusterDb[id].externalConnections) {\n    return id;\n  }\n  if (clusterDb[id]) {\n    return clusterDb[id].id;\n  }\n  return id;\n};\nconst adjustClustersAndEdges = (graph, depth) => {\n  if (!graph || depth > 10) {\n    log.debug(\"Opting out, no graph \");\n    return;\n  } else {\n    log.debug(\"Opting in, graph \");\n  }\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    if (children.length > 0) {\n      log.warn(\"Cluster identified\", id, \" Replacement id in edges: \", findNonClusterChild(id, graph));\n      descendants[id] = extractDescendants(id, graph);\n      clusterDb[id] = {\n        id: findNonClusterChild(id, graph),\n        clusterData: graph.node(id)\n      };\n    }\n  });\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    const edges = graph.edges();\n    if (children.length > 0) {\n      log.debug(\"Cluster identified\", id, descendants);\n      edges.forEach(edge => {\n        if (edge.v !== id && edge.w !== id) {\n          const d1 = isDescendant(edge.v, id);\n          const d2 = isDescendant(edge.w, id);\n          if (d1 ^ d2) {\n            log.warn(\"Edge: \", edge, \" leaves cluster \", id);\n            log.warn(\"Decendants of XXX \", id, \": \", descendants[id]);\n            clusterDb[id].externalConnections = true;\n          }\n        }\n      });\n    } else {\n      log.debug(\"Not a cluster \", id, descendants);\n    }\n  });\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.warn(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n    log.warn(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(graph.edge(e)));\n    let v = e.v;\n    let w = e.w;\n    log.warn(\"Fix XXX\", clusterDb, \"ids:\", e.v, e.w, \"Translating: \", clusterDb[e.v], \" --- \", clusterDb[e.w]);\n    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {\n      log.warn(\"Fixing and trixing link to self - removing XXX\", e.v, e.w, e.name);\n      log.warn(\"Fixing and trixing - removing XXX\", e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      const specialId = e.w + \"---\" + e.v;\n      graph.setNode(specialId, {\n        domId: specialId,\n        id: specialId,\n        labelStyle: \"\",\n        labelText: edge.label,\n        padding: 0,\n        shape: \"labelRect\",\n        style: \"\"\n      });\n      const edge1 = structuredClone(edge);\n      const edge2 = structuredClone(edge);\n      edge1.label = \"\";\n      edge1.arrowTypeEnd = \"none\";\n      edge2.label = \"\";\n      edge1.fromCluster = e.v;\n      edge2.toCluster = e.v;\n      graph.setEdge(v, specialId, edge1, e.name + \"-cyclic-special\");\n      graph.setEdge(specialId, w, edge2, e.name + \"-cyclic-special\");\n    } else if (clusterDb[e.v] || clusterDb[e.w]) {\n      log.warn(\"Fixing and trixing - removing XXX\", e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      if (v !== e.v) {\n        edge.fromCluster = e.v;\n      }\n      if (w !== e.w) {\n        edge.toCluster = e.w;\n      }\n      log.warn(\"Fix Replacing with XXX\", v, w, e.name);\n      graph.setEdge(v, w, edge, e.name);\n    }\n  });\n  log.warn(\"Adjusted Graph\", graphlibJson.write(graph));\n  extractor(graph, 0);\n  log.trace(clusterDb);\n};\nconst extractor = (graph, depth) => {\n  log.warn(\"extractor - \", depth, graphlibJson.write(graph), graph.children(\"D\"));\n  if (depth > 10) {\n    log.error(\"Bailing out\");\n    return;\n  }\n  let nodes = graph.nodes();\n  let hasChildren = false;\n  for (const node of nodes) {\n    const children = graph.children(node);\n    hasChildren = hasChildren || children.length > 0;\n  }\n  if (!hasChildren) {\n    log.debug(\"Done, no node has children\", graph.nodes());\n    return;\n  }\n  log.debug(\"Nodes = \", nodes, depth);\n  for (const node of nodes) {\n    log.debug(\"Extracting node\", node, clusterDb, clusterDb[node] && !clusterDb[node].externalConnections, !graph.parent(node), graph.node(node), graph.children(\"D\"), \" Depth \", depth);\n    if (!clusterDb[node]) {\n      log.debug(\"Not a cluster\", node, depth);\n    } else if (!clusterDb[node].externalConnections &&\n    // !graph.parent(node) &&\n    graph.children(node) && graph.children(node).length > 0) {\n      log.warn(\"Cluster without external connections, without a parent and with children\", node, depth);\n      const graphSettings = graph.graph();\n      let dir = graphSettings.rankdir === \"TB\" ? \"LR\" : \"TB\";\n      if (clusterDb[node] && clusterDb[node].clusterData && clusterDb[node].clusterData.dir) {\n        dir = clusterDb[node].clusterData.dir;\n        log.warn(\"Fixing dir\", clusterDb[node].clusterData.dir, dir);\n      }\n      const clusterGraph = new graphlib.Graph({\n        multigraph: true,\n        compound: true\n      }).setGraph({\n        rankdir: dir,\n        // Todo: set proper spacing\n        nodesep: 50,\n        ranksep: 50,\n        marginx: 8,\n        marginy: 8\n      }).setDefaultEdgeLabel(function () {\n        return {};\n      });\n      log.warn(\"Old graph before copy\", graphlibJson.write(graph));\n      copy(node, graph, clusterGraph, node);\n      graph.setNode(node, {\n        clusterNode: true,\n        id: node,\n        clusterData: clusterDb[node].clusterData,\n        labelText: clusterDb[node].labelText,\n        graph: clusterGraph\n      });\n      log.warn(\"New graph after copy node: (\", node, \")\", graphlibJson.write(clusterGraph));\n      log.debug(\"Old graph after copy\", graphlibJson.write(graph));\n    } else {\n      log.warn(\"Cluster ** \", node, \" **not meeting the criteria !externalConnections:\", !clusterDb[node].externalConnections, \" no parent: \", !graph.parent(node), \" children \", graph.children(node) && graph.children(node).length > 0, graph.children(\"D\"), depth);\n      log.debug(clusterDb);\n    }\n  }\n  nodes = graph.nodes();\n  log.warn(\"New list of nodes\", nodes);\n  for (const node of nodes) {\n    const data = graph.node(node);\n    log.warn(\" Now next level\", node, data);\n    if (data.clusterNode) {\n      extractor(data.graph, depth + 1);\n    }\n  }\n};\nconst sorter = (graph, nodes) => {\n  if (nodes.length === 0) {\n    return [];\n  }\n  let result = Object.assign(nodes);\n  nodes.forEach(node => {\n    const children = graph.children(node);\n    const sorted = sorter(graph, children);\n    result = [...result, ...sorted];\n  });\n  return result;\n};\nconst sortNodesByHierarchy = graph => sorter(graph, graph.children());\nconst rect = (parent, node) => {\n  log.info(\"Creating subgraph rect for \", node.id, node);\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"cluster\" + (node.class ? \" \" + node.class : \"\")).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const useHtmlLabels = evaluate(getConfig().flowchart.htmlLabels);\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"cluster-label\");\n  const text = node.labelType === \"markdown\" ? createText(label, node.labelText, {\n    style: node.labelStyle,\n    useHtmlLabels\n  }) : label.node().appendChild(createLabel(node.labelText, node.labelStyle, void 0, true));\n  let bbox = text.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;\n  if (node.width <= bbox.width + padding) {\n    node.diff = (bbox.width - node.width) / 2 - node.padding / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n  log.trace(\"Data \", node, JSON.stringify(node));\n  rect2.attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", node.x - width / 2).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", width).attr(\"height\", node.height + padding);\n  if (useHtmlLabels) {\n    label.attr(\"transform\",\n    // This puts the labal on top of the box instead of inside it\n    \"translate(\" + (node.x - bbox.width / 2) + \", \" + (node.y - node.height / 2) + \")\");\n  } else {\n    label.attr(\"transform\",\n    // This puts the labal on top of the box instead of inside it\n    \"translate(\" + node.x + \", \" + (node.y - node.height / 2) + \")\");\n  }\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst noteGroup = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"note-cluster\").attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  rect2.attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", node.x - node.width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", node.width + padding).attr(\"height\", node.height + padding).attr(\"fill\", \"none\");\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst roundedWithTitle = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", node.classes).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"cluster-label\");\n  const innerRect = shapeSvg.append(\"rect\");\n  const text = label.node().appendChild(createLabel(node.labelText, node.labelStyle, void 0, true));\n  let bbox = text.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  bbox = text.getBBox();\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;\n  if (node.width <= bbox.width + node.padding) {\n    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n  rect2.attr(\"class\", \"outer\").attr(\"x\", node.x - width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", width + padding).attr(\"height\", node.height + padding);\n  innerRect.attr(\"class\", \"inner\").attr(\"x\", node.x - width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding + bbox.height - 1).attr(\"width\", width + padding).attr(\"height\", node.height + padding - bbox.height - 3);\n  label.attr(\"transform\", \"translate(\" + (node.x - bbox.width / 2) + \", \" + (node.y - node.height / 2 - node.padding / 3 + (evaluate(getConfig().flowchart.htmlLabels) ? 5 : 3)) + \")\");\n  const rectBox = rect2.node().getBBox();\n  node.height = rectBox.height;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst divider = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", node.classes).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  rect2.attr(\"class\", \"divider\").attr(\"x\", node.x - node.width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2).attr(\"width\", node.width + padding).attr(\"height\", node.height + padding);\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.diff = -node.padding / 2;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst shapes = {\n  rect,\n  roundedWithTitle,\n  noteGroup,\n  divider\n};\nlet clusterElems = {};\nconst insertCluster = (elem, node) => {\n  log.trace(\"Inserting cluster\");\n  const shape = node.shape || \"rect\";\n  clusterElems[node.id] = shapes[shape](elem, node);\n};\nconst clear = () => {\n  clusterElems = {};\n};\nconst recursiveRender = async (_elem, graph, diagramtype, id, parentCluster) => {\n  log.info(\"Graph in recursive render: XXX\", graphlibJson.write(graph), parentCluster);\n  const dir = graph.graph().rankdir;\n  log.trace(\"Dir in recursive render - dir:\", dir);\n  const elem = _elem.insert(\"g\").attr(\"class\", \"root\");\n  if (!graph.nodes()) {\n    log.info(\"No nodes found for\", graph);\n  } else {\n    log.info(\"Recursive render XXX\", graph.nodes());\n  }\n  if (graph.edges().length > 0) {\n    log.trace(\"Recursive edges\", graph.edge(graph.edges()[0]));\n  }\n  const clusters = elem.insert(\"g\").attr(\"class\", \"clusters\");\n  const edgePaths = elem.insert(\"g\").attr(\"class\", \"edgePaths\");\n  const edgeLabels = elem.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  const nodes = elem.insert(\"g\").attr(\"class\", \"nodes\");\n  await Promise.all(graph.nodes().map(async function (v) {\n    const node = graph.node(v);\n    if (parentCluster !== void 0) {\n      const data = JSON.parse(JSON.stringify(parentCluster.clusterData));\n      log.info(\"Setting data for cluster XXX (\", v, \") \", data, parentCluster);\n      graph.setNode(parentCluster.id, data);\n      if (!graph.parent(v)) {\n        log.trace(\"Setting parent\", v, parentCluster.id);\n        graph.setParent(v, parentCluster.id, data);\n      }\n    }\n    log.info(\"(Insert) Node XXX\" + v + \": \" + JSON.stringify(graph.node(v)));\n    if (node && node.clusterNode) {\n      log.info(\"Cluster identified\", v, node.width, graph.node(v));\n      const o = await recursiveRender(nodes, node.graph, diagramtype, id, graph.node(v));\n      const newEl = o.elem;\n      updateNodeBounds(node, newEl);\n      node.diff = o.diff || 0;\n      log.info(\"Node bounds (abc123)\", v, node, node.width, node.x, node.y);\n      setNodeElem(newEl, node);\n      log.warn(\"Recursive render complete \", newEl, node);\n    } else {\n      if (graph.children(v).length > 0) {\n        log.info(\"Cluster - the non recursive path XXX\", v, node.id, node, graph);\n        log.info(findNonClusterChild(node.id, graph));\n        clusterDb[node.id] = {\n          id: findNonClusterChild(node.id, graph),\n          node\n        };\n      } else {\n        log.info(\"Node - the non recursive path\", v, node.id, node);\n        await insertNode(nodes, graph.node(v), dir);\n      }\n    }\n  }));\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e.v, e.w, e.name);\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \", e, \" \", JSON.stringify(graph.edge(e)));\n    log.info(\"Fix\", clusterDb, \"ids:\", e.v, e.w, \"Translateing: \", clusterDb[e.v], clusterDb[e.w]);\n    insertEdgeLabel(edgeLabels, edge);\n  });\n  graph.edges().forEach(function (e) {\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n  });\n  log.info(\"#############################################\");\n  log.info(\"###                Layout                 ###\");\n  log.info(\"#############################################\");\n  log.info(graph);\n  layout(graph);\n  log.info(\"Graph after layout:\", graphlibJson.write(graph));\n  let diff = 0;\n  sortNodesByHierarchy(graph).forEach(function (v) {\n    const node = graph.node(v);\n    log.info(\"Position \" + v + \": \" + JSON.stringify(graph.node(v)));\n    log.info(\"Position \" + v + \": (\" + node.x, \",\" + node.y, \") width: \", node.width, \" height: \", node.height);\n    if (node && node.clusterNode) {\n      positionNode(node);\n    } else {\n      if (graph.children(v).length > 0) {\n        insertCluster(clusters, node);\n        clusterDb[node.id].node = node;\n      } else {\n        positionNode(node);\n      }\n    }\n  });\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(edge), edge);\n    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph, id);\n    positionEdgeLabel(edge, paths);\n  });\n  graph.nodes().forEach(function (v) {\n    const n = graph.node(v);\n    log.info(v, n.type, n.diff);\n    if (n.type === \"group\") {\n      diff = n.diff;\n    }\n  });\n  return {\n    elem,\n    diff\n  };\n};\nconst render = async (elem, graph, markers, diagramtype, id) => {\n  insertMarkers(elem, markers, diagramtype, id);\n  clear$2();\n  clear$3();\n  clear();\n  clear$1();\n  log.warn(\"Graph at first:\", JSON.stringify(graphlibJson.write(graph)));\n  adjustClustersAndEdges(graph);\n  log.warn(\"Graph after:\", JSON.stringify(graphlibJson.write(graph)));\n  await recursiveRender(elem, graph, diagramtype, id);\n};\nexport { render as r };","import { p as parser, d as db, s as styles } from \"./styles-3dcbcfbf.js\";\nimport { select, curveLinear } from \"d3\";\nimport * as graphlib from \"dagre-d3-es/src/graphlib/index.js\";\nimport { l as log, c as getConfig, u as utils, o as setupGraphViewbox, n as interpolateToCurve, k as getStylesFromArray, e as common } from \"./mermaid-8af3addd.js\";\nimport { r as render } from \"./index-2c4b9a3b.js\";\nimport \"ts-dedent\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"lodash-es/merge.js\";\nimport \"stylis\";\nimport \"lodash-es/isEmpty.js\";\nimport \"dagre-d3-es/src/dagre/index.js\";\nimport \"dagre-d3-es/src/graphlib/json.js\";\nimport \"./edges-f2ad444c.js\";\nimport \"./createText-62fc7601.js\";\nimport \"mdast-util-from-markdown\";\nconst sanitizeText = txt => common.sanitizeText(txt, getConfig());\nlet conf = {\n  dividerMargin: 10,\n  padding: 5,\n  textHeight: 10,\n  curve: void 0\n};\nconst addNamespaces = function (namespaces, g, _id, diagObj) {\n  const keys = Object.keys(namespaces);\n  log.info(\"keys:\", keys);\n  log.info(namespaces);\n  keys.forEach(function (id) {\n    var _ref;\n    var _a, _b;\n    const vertex = namespaces[id];\n    const shape = \"rect\";\n    const node = {\n      shape,\n      id: vertex.id,\n      domId: vertex.domId,\n      labelText: sanitizeText(vertex.id),\n      labelStyle: \"\",\n      style: \"fill: none; stroke: black\",\n      // TODO V10: Flowchart ? Keeping flowchart for backwards compatibility. Remove in next major release\n      padding: (_ref = (_a = getConfig().flowchart) == null ? void 0 : _a.padding) !== null && _ref !== void 0 ? _ref : (_b = getConfig().class) == null ? void 0 : _b.padding\n    };\n    g.setNode(vertex.id, node);\n    addClasses(vertex.classes, g, _id, diagObj, vertex.id);\n    log.info(\"setNode\", node);\n  });\n};\nconst addClasses = function (classes, g, _id, diagObj, parent) {\n  const keys = Object.keys(classes);\n  log.info(\"keys:\", keys);\n  log.info(classes);\n  keys.filter(id => classes[id].parent == parent).forEach(function (id) {\n    var _vertex$label, _ref2;\n    var _a, _b;\n    const vertex = classes[id];\n    const cssClassStr = vertex.cssClasses.join(\" \");\n    const styles2 = {\n      labelStyle: \"\",\n      style: \"\"\n    };\n    const vertexText = (_vertex$label = vertex.label) !== null && _vertex$label !== void 0 ? _vertex$label : vertex.id;\n    const radius = 0;\n    const shape = \"class_box\";\n    const node = {\n      labelStyle: styles2.labelStyle,\n      shape,\n      labelText: sanitizeText(vertexText),\n      classData: vertex,\n      rx: radius,\n      ry: radius,\n      class: cssClassStr,\n      style: styles2.style,\n      id: vertex.id,\n      domId: vertex.domId,\n      tooltip: diagObj.db.getTooltip(vertex.id, parent) || \"\",\n      haveCallback: vertex.haveCallback,\n      link: vertex.link,\n      width: vertex.type === \"group\" ? 500 : void 0,\n      type: vertex.type,\n      // TODO V10: Flowchart ? Keeping flowchart for backwards compatibility. Remove in next major release\n      padding: (_ref2 = (_a = getConfig().flowchart) == null ? void 0 : _a.padding) !== null && _ref2 !== void 0 ? _ref2 : (_b = getConfig().class) == null ? void 0 : _b.padding\n    };\n    g.setNode(vertex.id, node);\n    if (parent) {\n      g.setParent(vertex.id, parent);\n    }\n    log.info(\"setNode\", node);\n  });\n};\nconst addNotes = function (notes, g, startEdgeId, classes) {\n  log.info(notes);\n  notes.forEach(function (note, i) {\n    var _ref3;\n    var _a, _b;\n    const vertex = note;\n    const cssNoteStr = \"\";\n    const styles2 = {\n      labelStyle: \"\",\n      style: \"\"\n    };\n    const vertexText = vertex.text;\n    const radius = 0;\n    const shape = \"note\";\n    const node = {\n      labelStyle: styles2.labelStyle,\n      shape,\n      labelText: sanitizeText(vertexText),\n      noteData: vertex,\n      rx: radius,\n      ry: radius,\n      class: cssNoteStr,\n      style: styles2.style,\n      id: vertex.id,\n      domId: vertex.id,\n      tooltip: \"\",\n      type: \"note\",\n      // TODO V10: Flowchart ? Keeping flowchart for backwards compatibility. Remove in next major release\n      padding: (_ref3 = (_a = getConfig().flowchart) == null ? void 0 : _a.padding) !== null && _ref3 !== void 0 ? _ref3 : (_b = getConfig().class) == null ? void 0 : _b.padding\n    };\n    g.setNode(vertex.id, node);\n    log.info(\"setNode\", node);\n    if (!vertex.class || !(vertex.class in classes)) {\n      return;\n    }\n    const edgeId = startEdgeId + i;\n    const edgeData = {\n      id: \"edgeNote\".concat(edgeId),\n      //Set relationship style and line type\n      classes: \"relation\",\n      pattern: \"dotted\",\n      // Set link type for rendering\n      arrowhead: \"none\",\n      //Set edge extra labels\n      startLabelRight: \"\",\n      endLabelLeft: \"\",\n      //Set relation arrow types\n      arrowTypeStart: \"none\",\n      arrowTypeEnd: \"none\",\n      style: \"fill:none\",\n      labelStyle: \"\",\n      curve: interpolateToCurve(conf.curve, curveLinear)\n    };\n    g.setEdge(vertex.id, vertex.class, edgeData, edgeId);\n  });\n};\nconst addRelations = function (relations, g) {\n  const conf2 = getConfig().flowchart;\n  let cnt = 0;\n  relations.forEach(function (edge) {\n    var _a;\n    cnt++;\n    const edgeData = {\n      //Set relationship style and line type\n      classes: \"relation\",\n      pattern: edge.relation.lineType == 1 ? \"dashed\" : \"solid\",\n      id: \"id\" + cnt,\n      // Set link type for rendering\n      arrowhead: edge.type === \"arrow_open\" ? \"none\" : \"normal\",\n      //Set edge extra labels\n      startLabelRight: edge.relationTitle1 === \"none\" ? \"\" : edge.relationTitle1,\n      endLabelLeft: edge.relationTitle2 === \"none\" ? \"\" : edge.relationTitle2,\n      //Set relation arrow types\n      arrowTypeStart: getArrowMarker(edge.relation.type1),\n      arrowTypeEnd: getArrowMarker(edge.relation.type2),\n      style: \"fill:none\",\n      labelStyle: \"\",\n      curve: interpolateToCurve(conf2 == null ? void 0 : conf2.curve, curveLinear)\n    };\n    log.info(edgeData, edge);\n    if (edge.style !== void 0) {\n      const styles2 = getStylesFromArray(edge.style);\n      edgeData.style = styles2.style;\n      edgeData.labelStyle = styles2.labelStyle;\n    }\n    edge.text = edge.title;\n    if (edge.text === void 0) {\n      if (edge.style !== void 0) {\n        edgeData.arrowheadStyle = \"fill: #333\";\n      }\n    } else {\n      var _ref4;\n      edgeData.arrowheadStyle = \"fill: #333\";\n      edgeData.labelpos = \"c\";\n      if ((_ref4 = (_a = getConfig().flowchart) == null ? void 0 : _a.htmlLabels) !== null && _ref4 !== void 0 ? _ref4 : getConfig().htmlLabels) {\n        edgeData.labelType = \"html\";\n        edgeData.label = '<span class=\"edgeLabel\">' + edge.text + \"</span>\";\n      } else {\n        edgeData.labelType = \"text\";\n        edgeData.label = edge.text.replace(common.lineBreakRegex, \"\\n\");\n        if (edge.style === void 0) {\n          edgeData.style = edgeData.style || \"stroke: #333; stroke-width: 1.5px;fill:none\";\n        }\n        edgeData.labelStyle = edgeData.labelStyle.replace(\"color:\", \"fill:\");\n      }\n    }\n    g.setEdge(edge.id1, edge.id2, edgeData, cnt);\n  });\n};\nconst setConf = function (cnf) {\n  conf = {\n    ...conf,\n    ...cnf\n  };\n};\nconst draw = async function (text, id, _version, diagObj) {\n  var _getConfig$flowchart, _ref5, _ref6, _ref7;\n  log.info(\"Drawing class - \", id);\n  const conf2 = (_getConfig$flowchart = getConfig().flowchart) !== null && _getConfig$flowchart !== void 0 ? _getConfig$flowchart : getConfig().class;\n  const securityLevel = getConfig().securityLevel;\n  log.info(\"config:\", conf2);\n  const nodeSpacing = (_ref5 = conf2 == null ? void 0 : conf2.nodeSpacing) !== null && _ref5 !== void 0 ? _ref5 : 50;\n  const rankSpacing = (_ref6 = conf2 == null ? void 0 : conf2.rankSpacing) !== null && _ref6 !== void 0 ? _ref6 : 50;\n  const g = new graphlib.Graph({\n    multigraph: true,\n    compound: true\n  }).setGraph({\n    rankdir: diagObj.db.getDirection(),\n    nodesep: nodeSpacing,\n    ranksep: rankSpacing,\n    marginx: 8,\n    marginy: 8\n  }).setDefaultEdgeLabel(function () {\n    return {};\n  });\n  const namespaces = diagObj.db.getNamespaces();\n  const classes = diagObj.db.getClasses();\n  const relations = diagObj.db.getRelations();\n  const notes = diagObj.db.getNotes();\n  log.info(relations);\n  addNamespaces(namespaces, g, id, diagObj);\n  addClasses(classes, g, id, diagObj);\n  addRelations(relations, g);\n  addNotes(notes, g, relations.length + 1, classes);\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const svg = root.select(\"[id=\\\"\".concat(id, \"\\\"]\"));\n  const element = root.select(\"#\" + id + \" g\");\n  await render(element, g, [\"aggregation\", \"extension\", \"composition\", \"dependency\", \"lollipop\"], \"classDiagram\", id);\n  utils.insertTitle(svg, \"classTitleText\", (_ref7 = conf2 == null ? void 0 : conf2.titleTopMargin) !== null && _ref7 !== void 0 ? _ref7 : 5, diagObj.db.getDiagramTitle());\n  setupGraphViewbox(g, svg, conf2 == null ? void 0 : conf2.diagramPadding, conf2 == null ? void 0 : conf2.useMaxWidth);\n  if (!(conf2 == null ? void 0 : conf2.htmlLabels)) {\n    const doc = securityLevel === \"sandbox\" ? sandboxElement.nodes()[0].contentDocument : document;\n    const labels = doc.querySelectorAll('[id=\"' + id + '\"] .edgeLabel .label');\n    for (const label of labels) {\n      const dim = label.getBBox();\n      const rect = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n      rect.setAttribute(\"rx\", 0);\n      rect.setAttribute(\"ry\", 0);\n      rect.setAttribute(\"width\", dim.width);\n      rect.setAttribute(\"height\", dim.height);\n      label.insertBefore(rect, label.firstChild);\n    }\n  }\n};\nfunction getArrowMarker(type) {\n  let marker;\n  switch (type) {\n    case 0:\n      marker = \"aggregation\";\n      break;\n    case 1:\n      marker = \"extension\";\n      break;\n    case 2:\n      marker = \"composition\";\n      break;\n    case 3:\n      marker = \"dependency\";\n      break;\n    case 4:\n      marker = \"lollipop\";\n      break;\n    default:\n      marker = \"none\";\n  }\n  return marker;\n}\nconst renderer = {\n  setConf,\n  draw\n};\nconst diagram = {\n  parser,\n  db,\n  renderer,\n  styles,\n  init: cnf => {\n    if (!cnf.class) {\n      cnf.class = {};\n    }\n    cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;\n    db.clear();\n  }\n};\nexport { diagram };"],"sourceRoot":""}