{"version":3,"sources":["../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/clone.js","../node_modules/.pnpm/dagre-d3-es@7.0.10/node_modules/dagre-d3-es/src/graphlib/json.js","../node_modules/.pnpm/mermaid@10.6.0/node_modules/mermaid/dist/index-2c4b9a3b.js","../node_modules/.pnpm/mermaid@10.6.0/node_modules/mermaid/dist/stateDiagram-v2-2b26beab.js"],"names":["CLONE_SYMBOLS_FLAG","lodash_es_clone","value","Object","_baseClone","write","g","json","options","directed","isDirected","multigraph","isMultigraph","compound","isCompound","nodes","writeNodes","edges","writeEdges","isUndefined","graph","map","v","nodeValue","node","parent","e","edgeValue","edge","w","name","__webpack_require__","d","__webpack_exports__","render","dagre_d3_es_src_dagre_index_js__WEBPACK_IMPORTED_MODULE_0__","dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__","_edges_f2ad444c_js__WEBPACK_IMPORTED_MODULE_2__","_mermaid_8af3addd_js__WEBPACK_IMPORTED_MODULE_3__","dagre_d3_es_src_graphlib_index_js__WEBPACK_IMPORTED_MODULE_4__","_createText_62fc7601_js__WEBPACK_IMPORTED_MODULE_5__","d3__WEBPACK_IMPORTED_MODULE_6__","clusterDb","descendants","parents","isDescendant","id","ancenstorId","trace","includes","copy","clusterId","newGraph","rootId","warn","children","push","forEach","length","data","info","setNode","setParent","debug","data2","edgeInCluster","setEdge","error","removeNode","extractDescendants","res","child","findNonClusterChild","_id","getAnchorId","externalConnections","extractor","depth","hasChildren","dir","rankdir","clusterData","clusterGraph","setGraph","nodesep","ranksep","marginx","marginy","setDefaultEdgeLabel","clusterNode","labelText","sorter","result","assign","sorted","shapes","rect","shapeSvg","insert","attr","class","rect2","useHtmlLabels","flowchart","htmlLabels","label","text","labelType","style","labelStyle","appendChild","bbox","getBBox","div","dv","getBoundingClientRect","width","height","padding","halfPadding","diff","JSON","stringify","rx","ry","x","y","rectBox","intersect","point","roundedWithTitle","classes","innerRect","append","noteGroup","divider","clusterElems","recursiveRender","async","_elem","diagramtype","parentCluster","elem","clusters","edgePaths","edgeLabels","Promise","all","parse","o","newEl","sortNodesByHierarchy","shape","insertCluster","paths","n","type","markers","removeEdge","specialId","domId","edge1","structuredClone","edge2","arrowTypeEnd","fromCluster","toCluster","adjustClustersAndEdges","r","diagram","_styles_9c745c82_js__WEBPACK_IMPORTED_MODULE_0__","dagre_d3_es_src_graphlib_index_js__WEBPACK_IMPORTED_MODULE_1__","d3__WEBPACK_IMPORTED_MODULE_2__","_index_2c4b9a3b_js__WEBPACK_IMPORTED_MODULE_4__","CSS_DIAGRAM_STATE","concat","CSS_EDGE_NOTE_EDGE","CSS_DIAGRAM_NOTE","CSS_DIAGRAM_CLUSTER","CSS_DIAGRAM_CLUSTER_ALT","DOMID_STATE","DOMID_TYPE_SPACER","NOTE_ID","PARENT_ID","nodeDb","graphItemCount","stateDomId","itemId","arguments","undefined","counter","typeSpacer","typeStr","setupNode","parsedItem","diagramStates","diagramDb","altFlag","classStr","dbInfoItem","join","getClassesFromDbInfo","start","description","sanitizeText","newNode","Array","isArray","sanitizeTextOrArray","doc","getDir","nodeData","centerLabel","note","noteData","groupData","parentNodeId","from","to","position","arrowhead","arrowType","arrowheadStyle","labelpos","thickness","setupDoc","parentParsedItem","item","stmt","state1","state2","edgeData","i","parsedItemDoc","renderer","setConf","cnf","keys","key","getClasses","diagramObj","db","extract","getRootDocV2","draw","_version","diag","getDirection","securityLevel","state","conf","nodeSpacing","rankSpacing","getStates","sandboxElement","root","contentDocument","body","svg","select","element","insertTitle","titleTopMargin","getDiagramTitle","bounds","svgBounds","useMaxWidth","vBox","labels","document","querySelectorAll","dim","createElementNS","setAttribute","insertBefore","firstChild","parser","styles","init","arrowMarkerAbsolute","clear"],"mappings":"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","file":"static/js/14.1614655b.chunk.js","sourcesContent":["import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\nexport default clone;","import * as _ from 'lodash-es';\nimport { Graph } from './graph.js';\nexport { write, read };\nfunction write(g) {\n  var json = {\n    options: {\n      directed: g.isDirected(),\n      multigraph: g.isMultigraph(),\n      compound: g.isCompound()\n    },\n    nodes: writeNodes(g),\n    edges: writeEdges(g)\n  };\n  if (!_.isUndefined(g.graph())) {\n    json.value = _.clone(g.graph());\n  }\n  return json;\n}\nfunction writeNodes(g) {\n  return _.map(g.nodes(), function (v) {\n    var nodeValue = g.node(v);\n    var parent = g.parent(v);\n    var node = {\n      v: v\n    };\n    if (!_.isUndefined(nodeValue)) {\n      node.value = nodeValue;\n    }\n    if (!_.isUndefined(parent)) {\n      node.parent = parent;\n    }\n    return node;\n  });\n}\nfunction writeEdges(g) {\n  return _.map(g.edges(), function (e) {\n    var edgeValue = g.edge(e);\n    var edge = {\n      v: e.v,\n      w: e.w\n    };\n    if (!_.isUndefined(e.name)) {\n      edge.name = e.name;\n    }\n    if (!_.isUndefined(edgeValue)) {\n      edge.value = edgeValue;\n    }\n    return edge;\n  });\n}\nfunction read(json) {\n  var g = new Graph(json.options).setGraph(json.value);\n  _.each(json.nodes, function (entry) {\n    g.setNode(entry.v, entry.value);\n    if (entry.parent) {\n      g.setParent(entry.v, entry.parent);\n    }\n  });\n  _.each(json.edges, function (entry) {\n    g.setEdge({\n      v: entry.v,\n      w: entry.w,\n      name: entry.name\n    }, entry.value);\n  });\n  return g;\n}","import { layout } from \"dagre-d3-es/src/dagre/index.js\";\nimport * as graphlibJson from \"dagre-d3-es/src/graphlib/json.js\";\nimport { c as createLabel, i as intersectRect, a as insertMarkers, b as clear$2, d as clear$3, u as updateNodeBounds, s as setNodeElem, e as insertNode, f as insertEdgeLabel, p as positionNode, g as insertEdge, h as positionEdgeLabel } from \"./edges-f2ad444c.js\";\nimport { l as log, m as evaluate, c as getConfig } from \"./mermaid-8af3addd.js\";\nimport * as graphlib from \"dagre-d3-es/src/graphlib/index.js\";\nimport { a as createText } from \"./createText-62fc7601.js\";\nimport { select } from \"d3\";\nlet clusterDb = {};\nlet descendants = {};\nlet parents = {};\nconst clear$1 = () => {\n  descendants = {};\n  parents = {};\n  clusterDb = {};\n};\nconst isDescendant = (id, ancenstorId) => {\n  log.trace(\"In isDecendant\", ancenstorId, \" \", id, \" = \", descendants[ancenstorId].includes(id));\n  if (descendants[ancenstorId].includes(id)) {\n    return true;\n  }\n  return false;\n};\nconst edgeInCluster = (edge, clusterId) => {\n  log.info(\"Decendants of \", clusterId, \" is \", descendants[clusterId]);\n  log.info(\"Edge is \", edge);\n  if (edge.v === clusterId) {\n    return false;\n  }\n  if (edge.w === clusterId) {\n    return false;\n  }\n  if (!descendants[clusterId]) {\n    log.debug(\"Tilt, \", clusterId, \",not in decendants\");\n    return false;\n  }\n  return descendants[clusterId].includes(edge.v) || isDescendant(edge.v, clusterId) || isDescendant(edge.w, clusterId) || descendants[clusterId].includes(edge.w);\n};\nconst copy = (clusterId, graph, newGraph, rootId) => {\n  log.warn(\"Copying children of \", clusterId, \"root\", rootId, \"data\", graph.node(clusterId), rootId);\n  const nodes = graph.children(clusterId) || [];\n  if (clusterId !== rootId) {\n    nodes.push(clusterId);\n  }\n  log.warn(\"Copying (nodes) clusterId\", clusterId, \"nodes\", nodes);\n  nodes.forEach(node => {\n    if (graph.children(node).length > 0) {\n      copy(node, graph, newGraph, rootId);\n    } else {\n      const data = graph.node(node);\n      log.info(\"cp \", node, \" to \", rootId, \" with parent \", clusterId);\n      newGraph.setNode(node, data);\n      if (rootId !== graph.parent(node)) {\n        log.warn(\"Setting parent\", node, graph.parent(node));\n        newGraph.setParent(node, graph.parent(node));\n      }\n      if (clusterId !== rootId && node !== clusterId) {\n        log.debug(\"Setting parent\", node, clusterId);\n        newGraph.setParent(node, clusterId);\n      } else {\n        log.info(\"In copy \", clusterId, \"root\", rootId, \"data\", graph.node(clusterId), rootId);\n        log.debug(\"Not Setting parent for node=\", node, \"cluster!==rootId\", clusterId !== rootId, \"node!==clusterId\", node !== clusterId);\n      }\n      const edges = graph.edges(node);\n      log.debug(\"Copying Edges\", edges);\n      edges.forEach(edge => {\n        log.info(\"Edge\", edge);\n        const data2 = graph.edge(edge.v, edge.w, edge.name);\n        log.info(\"Edge data\", data2, rootId);\n        try {\n          if (edgeInCluster(edge, rootId)) {\n            log.info(\"Copying as \", edge.v, edge.w, data2, edge.name);\n            newGraph.setEdge(edge.v, edge.w, data2, edge.name);\n            log.info(\"newGraph edges \", newGraph.edges(), newGraph.edge(newGraph.edges()[0]));\n          } else {\n            log.info(\"Skipping copy of edge \", edge.v, \"-->\", edge.w, \" rootId: \", rootId, \" clusterId:\", clusterId);\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      });\n    }\n    log.debug(\"Removing node\", node);\n    graph.removeNode(node);\n  });\n};\nconst extractDescendants = (id, graph) => {\n  const children = graph.children(id);\n  let res = [...children];\n  for (const child of children) {\n    parents[child] = id;\n    res = [...res, ...extractDescendants(child, graph)];\n  }\n  return res;\n};\nconst findNonClusterChild = (id, graph) => {\n  log.trace(\"Searching\", id);\n  const children = graph.children(id);\n  log.trace(\"Searching children of id \", id, children);\n  if (children.length < 1) {\n    log.trace(\"This is a valid node\", id);\n    return id;\n  }\n  for (const child of children) {\n    const _id = findNonClusterChild(child, graph);\n    if (_id) {\n      log.trace(\"Found replacement for\", id, \" => \", _id);\n      return _id;\n    }\n  }\n};\nconst getAnchorId = id => {\n  if (!clusterDb[id]) {\n    return id;\n  }\n  if (!clusterDb[id].externalConnections) {\n    return id;\n  }\n  if (clusterDb[id]) {\n    return clusterDb[id].id;\n  }\n  return id;\n};\nconst adjustClustersAndEdges = (graph, depth) => {\n  if (!graph || depth > 10) {\n    log.debug(\"Opting out, no graph \");\n    return;\n  } else {\n    log.debug(\"Opting in, graph \");\n  }\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    if (children.length > 0) {\n      log.warn(\"Cluster identified\", id, \" Replacement id in edges: \", findNonClusterChild(id, graph));\n      descendants[id] = extractDescendants(id, graph);\n      clusterDb[id] = {\n        id: findNonClusterChild(id, graph),\n        clusterData: graph.node(id)\n      };\n    }\n  });\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    const edges = graph.edges();\n    if (children.length > 0) {\n      log.debug(\"Cluster identified\", id, descendants);\n      edges.forEach(edge => {\n        if (edge.v !== id && edge.w !== id) {\n          const d1 = isDescendant(edge.v, id);\n          const d2 = isDescendant(edge.w, id);\n          if (d1 ^ d2) {\n            log.warn(\"Edge: \", edge, \" leaves cluster \", id);\n            log.warn(\"Decendants of XXX \", id, \": \", descendants[id]);\n            clusterDb[id].externalConnections = true;\n          }\n        }\n      });\n    } else {\n      log.debug(\"Not a cluster \", id, descendants);\n    }\n  });\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.warn(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n    log.warn(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(graph.edge(e)));\n    let v = e.v;\n    let w = e.w;\n    log.warn(\"Fix XXX\", clusterDb, \"ids:\", e.v, e.w, \"Translating: \", clusterDb[e.v], \" --- \", clusterDb[e.w]);\n    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {\n      log.warn(\"Fixing and trixing link to self - removing XXX\", e.v, e.w, e.name);\n      log.warn(\"Fixing and trixing - removing XXX\", e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      const specialId = e.w + \"---\" + e.v;\n      graph.setNode(specialId, {\n        domId: specialId,\n        id: specialId,\n        labelStyle: \"\",\n        labelText: edge.label,\n        padding: 0,\n        shape: \"labelRect\",\n        style: \"\"\n      });\n      const edge1 = structuredClone(edge);\n      const edge2 = structuredClone(edge);\n      edge1.label = \"\";\n      edge1.arrowTypeEnd = \"none\";\n      edge2.label = \"\";\n      edge1.fromCluster = e.v;\n      edge2.toCluster = e.v;\n      graph.setEdge(v, specialId, edge1, e.name + \"-cyclic-special\");\n      graph.setEdge(specialId, w, edge2, e.name + \"-cyclic-special\");\n    } else if (clusterDb[e.v] || clusterDb[e.w]) {\n      log.warn(\"Fixing and trixing - removing XXX\", e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      if (v !== e.v) {\n        edge.fromCluster = e.v;\n      }\n      if (w !== e.w) {\n        edge.toCluster = e.w;\n      }\n      log.warn(\"Fix Replacing with XXX\", v, w, e.name);\n      graph.setEdge(v, w, edge, e.name);\n    }\n  });\n  log.warn(\"Adjusted Graph\", graphlibJson.write(graph));\n  extractor(graph, 0);\n  log.trace(clusterDb);\n};\nconst extractor = (graph, depth) => {\n  log.warn(\"extractor - \", depth, graphlibJson.write(graph), graph.children(\"D\"));\n  if (depth > 10) {\n    log.error(\"Bailing out\");\n    return;\n  }\n  let nodes = graph.nodes();\n  let hasChildren = false;\n  for (const node of nodes) {\n    const children = graph.children(node);\n    hasChildren = hasChildren || children.length > 0;\n  }\n  if (!hasChildren) {\n    log.debug(\"Done, no node has children\", graph.nodes());\n    return;\n  }\n  log.debug(\"Nodes = \", nodes, depth);\n  for (const node of nodes) {\n    log.debug(\"Extracting node\", node, clusterDb, clusterDb[node] && !clusterDb[node].externalConnections, !graph.parent(node), graph.node(node), graph.children(\"D\"), \" Depth \", depth);\n    if (!clusterDb[node]) {\n      log.debug(\"Not a cluster\", node, depth);\n    } else if (!clusterDb[node].externalConnections &&\n    // !graph.parent(node) &&\n    graph.children(node) && graph.children(node).length > 0) {\n      log.warn(\"Cluster without external connections, without a parent and with children\", node, depth);\n      const graphSettings = graph.graph();\n      let dir = graphSettings.rankdir === \"TB\" ? \"LR\" : \"TB\";\n      if (clusterDb[node] && clusterDb[node].clusterData && clusterDb[node].clusterData.dir) {\n        dir = clusterDb[node].clusterData.dir;\n        log.warn(\"Fixing dir\", clusterDb[node].clusterData.dir, dir);\n      }\n      const clusterGraph = new graphlib.Graph({\n        multigraph: true,\n        compound: true\n      }).setGraph({\n        rankdir: dir,\n        // Todo: set proper spacing\n        nodesep: 50,\n        ranksep: 50,\n        marginx: 8,\n        marginy: 8\n      }).setDefaultEdgeLabel(function () {\n        return {};\n      });\n      log.warn(\"Old graph before copy\", graphlibJson.write(graph));\n      copy(node, graph, clusterGraph, node);\n      graph.setNode(node, {\n        clusterNode: true,\n        id: node,\n        clusterData: clusterDb[node].clusterData,\n        labelText: clusterDb[node].labelText,\n        graph: clusterGraph\n      });\n      log.warn(\"New graph after copy node: (\", node, \")\", graphlibJson.write(clusterGraph));\n      log.debug(\"Old graph after copy\", graphlibJson.write(graph));\n    } else {\n      log.warn(\"Cluster ** \", node, \" **not meeting the criteria !externalConnections:\", !clusterDb[node].externalConnections, \" no parent: \", !graph.parent(node), \" children \", graph.children(node) && graph.children(node).length > 0, graph.children(\"D\"), depth);\n      log.debug(clusterDb);\n    }\n  }\n  nodes = graph.nodes();\n  log.warn(\"New list of nodes\", nodes);\n  for (const node of nodes) {\n    const data = graph.node(node);\n    log.warn(\" Now next level\", node, data);\n    if (data.clusterNode) {\n      extractor(data.graph, depth + 1);\n    }\n  }\n};\nconst sorter = (graph, nodes) => {\n  if (nodes.length === 0) {\n    return [];\n  }\n  let result = Object.assign(nodes);\n  nodes.forEach(node => {\n    const children = graph.children(node);\n    const sorted = sorter(graph, children);\n    result = [...result, ...sorted];\n  });\n  return result;\n};\nconst sortNodesByHierarchy = graph => sorter(graph, graph.children());\nconst rect = (parent, node) => {\n  log.info(\"Creating subgraph rect for \", node.id, node);\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"cluster\" + (node.class ? \" \" + node.class : \"\")).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const useHtmlLabels = evaluate(getConfig().flowchart.htmlLabels);\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"cluster-label\");\n  const text = node.labelType === \"markdown\" ? createText(label, node.labelText, {\n    style: node.labelStyle,\n    useHtmlLabels\n  }) : label.node().appendChild(createLabel(node.labelText, node.labelStyle, void 0, true));\n  let bbox = text.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;\n  if (node.width <= bbox.width + padding) {\n    node.diff = (bbox.width - node.width) / 2 - node.padding / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n  log.trace(\"Data \", node, JSON.stringify(node));\n  rect2.attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", node.x - width / 2).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", width).attr(\"height\", node.height + padding);\n  if (useHtmlLabels) {\n    label.attr(\"transform\",\n    // This puts the labal on top of the box instead of inside it\n    \"translate(\" + (node.x - bbox.width / 2) + \", \" + (node.y - node.height / 2) + \")\");\n  } else {\n    label.attr(\"transform\",\n    // This puts the labal on top of the box instead of inside it\n    \"translate(\" + node.x + \", \" + (node.y - node.height / 2) + \")\");\n  }\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst noteGroup = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"note-cluster\").attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  rect2.attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", node.x - node.width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", node.width + padding).attr(\"height\", node.height + padding).attr(\"fill\", \"none\");\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst roundedWithTitle = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", node.classes).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"cluster-label\");\n  const innerRect = shapeSvg.append(\"rect\");\n  const text = label.node().appendChild(createLabel(node.labelText, node.labelStyle, void 0, true));\n  let bbox = text.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  bbox = text.getBBox();\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;\n  if (node.width <= bbox.width + node.padding) {\n    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n  rect2.attr(\"class\", \"outer\").attr(\"x\", node.x - width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", width + padding).attr(\"height\", node.height + padding);\n  innerRect.attr(\"class\", \"inner\").attr(\"x\", node.x - width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding + bbox.height - 1).attr(\"width\", width + padding).attr(\"height\", node.height + padding - bbox.height - 3);\n  label.attr(\"transform\", \"translate(\" + (node.x - bbox.width / 2) + \", \" + (node.y - node.height / 2 - node.padding / 3 + (evaluate(getConfig().flowchart.htmlLabels) ? 5 : 3)) + \")\");\n  const rectBox = rect2.node().getBBox();\n  node.height = rectBox.height;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst divider = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", node.classes).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  rect2.attr(\"class\", \"divider\").attr(\"x\", node.x - node.width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2).attr(\"width\", node.width + padding).attr(\"height\", node.height + padding);\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.diff = -node.padding / 2;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst shapes = {\n  rect,\n  roundedWithTitle,\n  noteGroup,\n  divider\n};\nlet clusterElems = {};\nconst insertCluster = (elem, node) => {\n  log.trace(\"Inserting cluster\");\n  const shape = node.shape || \"rect\";\n  clusterElems[node.id] = shapes[shape](elem, node);\n};\nconst clear = () => {\n  clusterElems = {};\n};\nconst recursiveRender = async (_elem, graph, diagramtype, id, parentCluster) => {\n  log.info(\"Graph in recursive render: XXX\", graphlibJson.write(graph), parentCluster);\n  const dir = graph.graph().rankdir;\n  log.trace(\"Dir in recursive render - dir:\", dir);\n  const elem = _elem.insert(\"g\").attr(\"class\", \"root\");\n  if (!graph.nodes()) {\n    log.info(\"No nodes found for\", graph);\n  } else {\n    log.info(\"Recursive render XXX\", graph.nodes());\n  }\n  if (graph.edges().length > 0) {\n    log.trace(\"Recursive edges\", graph.edge(graph.edges()[0]));\n  }\n  const clusters = elem.insert(\"g\").attr(\"class\", \"clusters\");\n  const edgePaths = elem.insert(\"g\").attr(\"class\", \"edgePaths\");\n  const edgeLabels = elem.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  const nodes = elem.insert(\"g\").attr(\"class\", \"nodes\");\n  await Promise.all(graph.nodes().map(async function (v) {\n    const node = graph.node(v);\n    if (parentCluster !== void 0) {\n      const data = JSON.parse(JSON.stringify(parentCluster.clusterData));\n      log.info(\"Setting data for cluster XXX (\", v, \") \", data, parentCluster);\n      graph.setNode(parentCluster.id, data);\n      if (!graph.parent(v)) {\n        log.trace(\"Setting parent\", v, parentCluster.id);\n        graph.setParent(v, parentCluster.id, data);\n      }\n    }\n    log.info(\"(Insert) Node XXX\" + v + \": \" + JSON.stringify(graph.node(v)));\n    if (node && node.clusterNode) {\n      log.info(\"Cluster identified\", v, node.width, graph.node(v));\n      const o = await recursiveRender(nodes, node.graph, diagramtype, id, graph.node(v));\n      const newEl = o.elem;\n      updateNodeBounds(node, newEl);\n      node.diff = o.diff || 0;\n      log.info(\"Node bounds (abc123)\", v, node, node.width, node.x, node.y);\n      setNodeElem(newEl, node);\n      log.warn(\"Recursive render complete \", newEl, node);\n    } else {\n      if (graph.children(v).length > 0) {\n        log.info(\"Cluster - the non recursive path XXX\", v, node.id, node, graph);\n        log.info(findNonClusterChild(node.id, graph));\n        clusterDb[node.id] = {\n          id: findNonClusterChild(node.id, graph),\n          node\n        };\n      } else {\n        log.info(\"Node - the non recursive path\", v, node.id, node);\n        await insertNode(nodes, graph.node(v), dir);\n      }\n    }\n  }));\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e.v, e.w, e.name);\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \", e, \" \", JSON.stringify(graph.edge(e)));\n    log.info(\"Fix\", clusterDb, \"ids:\", e.v, e.w, \"Translateing: \", clusterDb[e.v], clusterDb[e.w]);\n    insertEdgeLabel(edgeLabels, edge);\n  });\n  graph.edges().forEach(function (e) {\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n  });\n  log.info(\"#############################################\");\n  log.info(\"###                Layout                 ###\");\n  log.info(\"#############################################\");\n  log.info(graph);\n  layout(graph);\n  log.info(\"Graph after layout:\", graphlibJson.write(graph));\n  let diff = 0;\n  sortNodesByHierarchy(graph).forEach(function (v) {\n    const node = graph.node(v);\n    log.info(\"Position \" + v + \": \" + JSON.stringify(graph.node(v)));\n    log.info(\"Position \" + v + \": (\" + node.x, \",\" + node.y, \") width: \", node.width, \" height: \", node.height);\n    if (node && node.clusterNode) {\n      positionNode(node);\n    } else {\n      if (graph.children(v).length > 0) {\n        insertCluster(clusters, node);\n        clusterDb[node.id].node = node;\n      } else {\n        positionNode(node);\n      }\n    }\n  });\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(edge), edge);\n    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph, id);\n    positionEdgeLabel(edge, paths);\n  });\n  graph.nodes().forEach(function (v) {\n    const n = graph.node(v);\n    log.info(v, n.type, n.diff);\n    if (n.type === \"group\") {\n      diff = n.diff;\n    }\n  });\n  return {\n    elem,\n    diff\n  };\n};\nconst render = async (elem, graph, markers, diagramtype, id) => {\n  insertMarkers(elem, markers, diagramtype, id);\n  clear$2();\n  clear$3();\n  clear();\n  clear$1();\n  log.warn(\"Graph at first:\", JSON.stringify(graphlibJson.write(graph)));\n  adjustClustersAndEdges(graph);\n  log.warn(\"Graph after:\", JSON.stringify(graphlibJson.write(graph)));\n  await recursiveRender(elem, graph, diagramtype, id);\n};\nexport { render as r };","import { D as DEFAULT_STATE_TYPE, a as DIVIDER_TYPE, S as STMT_RELATION, b as STMT_STATE, c as DEFAULT_NESTED_DOC_DIR, p as parser, d as db, s as styles } from \"./styles-9c745c82.js\";\nimport * as graphlib from \"dagre-d3-es/src/graphlib/index.js\";\nimport { select } from \"d3\";\nimport { l as log, c as getConfig, u as utils, i as configureSvgSize, e as common } from \"./mermaid-8af3addd.js\";\nimport { r as render } from \"./index-2c4b9a3b.js\";\nimport \"ts-dedent\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"lodash-es/merge.js\";\nimport \"stylis\";\nimport \"lodash-es/isEmpty.js\";\nimport \"dagre-d3-es/src/dagre/index.js\";\nimport \"dagre-d3-es/src/graphlib/json.js\";\nimport \"./edges-f2ad444c.js\";\nimport \"./createText-62fc7601.js\";\nimport \"mdast-util-from-markdown\";\nconst SHAPE_STATE = \"rect\";\nconst SHAPE_STATE_WITH_DESC = \"rectWithTitle\";\nconst SHAPE_START = \"start\";\nconst SHAPE_END = \"end\";\nconst SHAPE_DIVIDER = \"divider\";\nconst SHAPE_GROUP = \"roundedWithTitle\";\nconst SHAPE_NOTE = \"note\";\nconst SHAPE_NOTEGROUP = \"noteGroup\";\nconst CSS_DIAGRAM = \"statediagram\";\nconst CSS_STATE = \"state\";\nconst CSS_DIAGRAM_STATE = \"\".concat(CSS_DIAGRAM, \"-\").concat(CSS_STATE);\nconst CSS_EDGE = \"transition\";\nconst CSS_NOTE = \"note\";\nconst CSS_NOTE_EDGE = \"note-edge\";\nconst CSS_EDGE_NOTE_EDGE = \"\".concat(CSS_EDGE, \" \").concat(CSS_NOTE_EDGE);\nconst CSS_DIAGRAM_NOTE = \"\".concat(CSS_DIAGRAM, \"-\").concat(CSS_NOTE);\nconst CSS_CLUSTER = \"cluster\";\nconst CSS_DIAGRAM_CLUSTER = \"\".concat(CSS_DIAGRAM, \"-\").concat(CSS_CLUSTER);\nconst CSS_CLUSTER_ALT = \"cluster-alt\";\nconst CSS_DIAGRAM_CLUSTER_ALT = \"\".concat(CSS_DIAGRAM, \"-\").concat(CSS_CLUSTER_ALT);\nconst PARENT = \"parent\";\nconst NOTE = \"note\";\nconst DOMID_STATE = \"state\";\nconst DOMID_TYPE_SPACER = \"----\";\nconst NOTE_ID = \"\".concat(DOMID_TYPE_SPACER).concat(NOTE);\nconst PARENT_ID = \"\".concat(DOMID_TYPE_SPACER).concat(PARENT);\nconst G_EDGE_STYLE = \"fill:none\";\nconst G_EDGE_ARROWHEADSTYLE = \"fill: #333\";\nconst G_EDGE_LABELPOS = \"c\";\nconst G_EDGE_LABELTYPE = \"text\";\nconst G_EDGE_THICKNESS = \"normal\";\nlet nodeDb = {};\nlet graphItemCount = 0;\nconst setConf = function (cnf) {\n  const keys = Object.keys(cnf);\n  for (const key of keys) {\n    cnf[key];\n  }\n};\nconst getClasses = function (text, diagramObj) {\n  diagramObj.db.extract(diagramObj.db.getRootDocV2());\n  return diagramObj.db.getClasses();\n};\nfunction getClassesFromDbInfo(dbInfoItem) {\n  if (dbInfoItem === void 0 || dbInfoItem === null) {\n    return \"\";\n  } else {\n    if (dbInfoItem.classes) {\n      return dbInfoItem.classes.join(\" \");\n    } else {\n      return \"\";\n    }\n  }\n}\nfunction stateDomId() {\n  let itemId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  let counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let typeSpacer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DOMID_TYPE_SPACER;\n  const typeStr = type !== null && type.length > 0 ? \"\".concat(typeSpacer).concat(type) : \"\";\n  return \"\".concat(DOMID_STATE, \"-\").concat(itemId).concat(typeStr, \"-\").concat(counter);\n}\nconst setupNode = (g, parent, parsedItem, diagramStates, diagramDb, altFlag) => {\n  const itemId = parsedItem.id;\n  const classStr = getClassesFromDbInfo(diagramStates[itemId]);\n  if (itemId !== \"root\") {\n    let shape = SHAPE_STATE;\n    if (parsedItem.start === true) {\n      shape = SHAPE_START;\n    }\n    if (parsedItem.start === false) {\n      shape = SHAPE_END;\n    }\n    if (parsedItem.type !== DEFAULT_STATE_TYPE) {\n      shape = parsedItem.type;\n    }\n    if (!nodeDb[itemId]) {\n      nodeDb[itemId] = {\n        id: itemId,\n        shape,\n        description: common.sanitizeText(itemId, getConfig()),\n        classes: \"\".concat(classStr, \" \").concat(CSS_DIAGRAM_STATE)\n      };\n    }\n    const newNode = nodeDb[itemId];\n    if (parsedItem.description) {\n      if (Array.isArray(newNode.description)) {\n        newNode.shape = SHAPE_STATE_WITH_DESC;\n        newNode.description.push(parsedItem.description);\n      } else {\n        if (newNode.description.length > 0) {\n          newNode.shape = SHAPE_STATE_WITH_DESC;\n          if (newNode.description === itemId) {\n            newNode.description = [parsedItem.description];\n          } else {\n            newNode.description = [newNode.description, parsedItem.description];\n          }\n        } else {\n          newNode.shape = SHAPE_STATE;\n          newNode.description = parsedItem.description;\n        }\n      }\n      newNode.description = common.sanitizeTextOrArray(newNode.description, getConfig());\n    }\n    if (newNode.description.length === 1 && newNode.shape === SHAPE_STATE_WITH_DESC) {\n      newNode.shape = SHAPE_STATE;\n    }\n    if (!newNode.type && parsedItem.doc) {\n      log.info(\"Setting cluster for \", itemId, getDir(parsedItem));\n      newNode.type = \"group\";\n      newNode.dir = getDir(parsedItem);\n      newNode.shape = parsedItem.type === DIVIDER_TYPE ? SHAPE_DIVIDER : SHAPE_GROUP;\n      newNode.classes = newNode.classes + \" \" + CSS_DIAGRAM_CLUSTER + \" \" + (altFlag ? CSS_DIAGRAM_CLUSTER_ALT : \"\");\n    }\n    const nodeData = {\n      labelStyle: \"\",\n      shape: newNode.shape,\n      labelText: newNode.description,\n      // typeof newNode.description === 'object'\n      //   ? newNode.description[0]\n      //   : newNode.description,\n      classes: newNode.classes,\n      style: \"\",\n      //styles.style,\n      id: itemId,\n      dir: newNode.dir,\n      domId: stateDomId(itemId, graphItemCount),\n      type: newNode.type,\n      padding: 15\n      //getConfig().flowchart.padding\n    };\n    nodeData.centerLabel = true;\n    if (parsedItem.note) {\n      const noteData = {\n        labelStyle: \"\",\n        shape: SHAPE_NOTE,\n        labelText: parsedItem.note.text,\n        classes: CSS_DIAGRAM_NOTE,\n        // useHtmlLabels: false,\n        style: \"\",\n        // styles.style,\n        id: itemId + NOTE_ID + \"-\" + graphItemCount,\n        domId: stateDomId(itemId, graphItemCount, NOTE),\n        type: newNode.type,\n        padding: 15\n        //getConfig().flowchart.padding\n      };\n      const groupData = {\n        labelStyle: \"\",\n        shape: SHAPE_NOTEGROUP,\n        labelText: parsedItem.note.text,\n        classes: newNode.classes,\n        style: \"\",\n        // styles.style,\n        id: itemId + PARENT_ID,\n        domId: stateDomId(itemId, graphItemCount, PARENT),\n        type: \"group\",\n        padding: 0\n        //getConfig().flowchart.padding\n      };\n      graphItemCount++;\n      const parentNodeId = itemId + PARENT_ID;\n      g.setNode(parentNodeId, groupData);\n      g.setNode(noteData.id, noteData);\n      g.setNode(itemId, nodeData);\n      g.setParent(itemId, parentNodeId);\n      g.setParent(noteData.id, parentNodeId);\n      let from = itemId;\n      let to = noteData.id;\n      if (parsedItem.note.position === \"left of\") {\n        from = noteData.id;\n        to = itemId;\n      }\n      g.setEdge(from, to, {\n        arrowhead: \"none\",\n        arrowType: \"\",\n        style: G_EDGE_STYLE,\n        labelStyle: \"\",\n        classes: CSS_EDGE_NOTE_EDGE,\n        arrowheadStyle: G_EDGE_ARROWHEADSTYLE,\n        labelpos: G_EDGE_LABELPOS,\n        labelType: G_EDGE_LABELTYPE,\n        thickness: G_EDGE_THICKNESS\n      });\n    } else {\n      g.setNode(itemId, nodeData);\n    }\n  }\n  if (parent && parent.id !== \"root\") {\n    log.trace(\"Setting node \", itemId, \" to be child of its parent \", parent.id);\n    g.setParent(itemId, parent.id);\n  }\n  if (parsedItem.doc) {\n    log.trace(\"Adding nodes children \");\n    setupDoc(g, parsedItem, parsedItem.doc, diagramStates, diagramDb, !altFlag);\n  }\n};\nconst setupDoc = (g, parentParsedItem, doc, diagramStates, diagramDb, altFlag) => {\n  log.trace(\"items\", doc);\n  doc.forEach(item => {\n    switch (item.stmt) {\n      case STMT_STATE:\n        setupNode(g, parentParsedItem, item, diagramStates, diagramDb, altFlag);\n        break;\n      case DEFAULT_STATE_TYPE:\n        setupNode(g, parentParsedItem, item, diagramStates, diagramDb, altFlag);\n        break;\n      case STMT_RELATION:\n        {\n          setupNode(g, parentParsedItem, item.state1, diagramStates, diagramDb, altFlag);\n          setupNode(g, parentParsedItem, item.state2, diagramStates, diagramDb, altFlag);\n          const edgeData = {\n            id: \"edge\" + graphItemCount,\n            arrowhead: \"normal\",\n            arrowTypeEnd: \"arrow_barb\",\n            style: G_EDGE_STYLE,\n            labelStyle: \"\",\n            label: common.sanitizeText(item.description, getConfig()),\n            arrowheadStyle: G_EDGE_ARROWHEADSTYLE,\n            labelpos: G_EDGE_LABELPOS,\n            labelType: G_EDGE_LABELTYPE,\n            thickness: G_EDGE_THICKNESS,\n            classes: CSS_EDGE\n          };\n          g.setEdge(item.state1.id, item.state2.id, edgeData, graphItemCount);\n          graphItemCount++;\n        }\n        break;\n    }\n  });\n};\nconst getDir = function (parsedItem) {\n  let defaultDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_NESTED_DOC_DIR;\n  let dir = defaultDir;\n  if (parsedItem.doc) {\n    for (let i = 0; i < parsedItem.doc.length; i++) {\n      const parsedItemDoc = parsedItem.doc[i];\n      if (parsedItemDoc.stmt === \"dir\") {\n        dir = parsedItemDoc.value;\n      }\n    }\n  }\n  return dir;\n};\nconst draw = async function (text, id, _version, diag) {\n  log.info(\"Drawing state diagram (v2)\", id);\n  nodeDb = {};\n  diag.db.getDirection();\n  const {\n    securityLevel,\n    state: conf\n  } = getConfig();\n  const nodeSpacing = conf.nodeSpacing || 50;\n  const rankSpacing = conf.rankSpacing || 50;\n  log.info(diag.db.getRootDocV2());\n  diag.db.extract(diag.db.getRootDocV2());\n  log.info(diag.db.getRootDocV2());\n  const diagramStates = diag.db.getStates();\n  const g = new graphlib.Graph({\n    multigraph: true,\n    compound: true\n  }).setGraph({\n    rankdir: getDir(diag.db.getRootDocV2()),\n    nodesep: nodeSpacing,\n    ranksep: rankSpacing,\n    marginx: 8,\n    marginy: 8\n  }).setDefaultEdgeLabel(function () {\n    return {};\n  });\n  setupNode(g, void 0, diag.db.getRootDocV2(), diagramStates, diag.db, true);\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const svg = root.select(\"[id=\\\"\".concat(id, \"\\\"]\"));\n  const element = root.select(\"#\" + id + \" g\");\n  await render(element, g, [\"barb\"], CSS_DIAGRAM, id);\n  const padding = 8;\n  utils.insertTitle(svg, \"statediagramTitleText\", conf.titleTopMargin, diag.db.getDiagramTitle());\n  const bounds = svg.node().getBBox();\n  const width = bounds.width + padding * 2;\n  const height = bounds.height + padding * 2;\n  svg.attr(\"class\", CSS_DIAGRAM);\n  const svgBounds = svg.node().getBBox();\n  configureSvgSize(svg, height, width, conf.useMaxWidth);\n  const vBox = \"\".concat(svgBounds.x - padding, \" \").concat(svgBounds.y - padding, \" \").concat(width, \" \").concat(height);\n  log.debug(\"viewBox \".concat(vBox));\n  svg.attr(\"viewBox\", vBox);\n  const labels = document.querySelectorAll('[id=\"' + id + '\"] .edgeLabel .label');\n  for (const label of labels) {\n    const dim = label.getBBox();\n    const rect = document.createElementNS(\"http://www.w3.org/2000/svg\", SHAPE_STATE);\n    rect.setAttribute(\"rx\", 0);\n    rect.setAttribute(\"ry\", 0);\n    rect.setAttribute(\"width\", dim.width);\n    rect.setAttribute(\"height\", dim.height);\n    label.insertBefore(rect, label.firstChild);\n  }\n};\nconst renderer = {\n  setConf,\n  getClasses,\n  draw\n};\nconst diagram = {\n  parser,\n  db,\n  renderer,\n  styles,\n  init: cnf => {\n    if (!cnf.state) {\n      cnf.state = {};\n    }\n    cnf.state.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;\n    db.clear();\n  }\n};\nexport { diagram };"],"sourceRoot":""}