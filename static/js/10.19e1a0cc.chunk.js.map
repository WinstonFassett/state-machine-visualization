{"version":3,"sources":["../node_modules/.pnpm/dagre-d3-es@7.0.10/node_modules/dagre-d3-es/src/dagre-js/util.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/clone.js","../node_modules/.pnpm/dagre-d3-es@7.0.10/node_modules/dagre-d3-es/src/graphlib/json.js","../node_modules/.pnpm/mermaid@10.6.0/node_modules/mermaid/dist/index-2c4b9a3b.js","../node_modules/.pnpm/dagre-d3-es@7.0.10/node_modules/dagre-d3-es/src/dagre-js/label/add-html-label.js","../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/channel.js","../node_modules/.pnpm/mermaid@10.6.0/node_modules/mermaid/dist/styles-080da4f6.js","../node_modules/.pnpm/dagre-d3-es@7.0.10/node_modules/dagre-d3-es/src/dagre-js/render.js","../node_modules/.pnpm/mermaid@10.6.0/node_modules/mermaid/dist/flowDiagram-7ea5b25a.js"],"names":["__webpack_require__","d","__webpack_exports__","isSubgraph","edgeToId","applyStyle","applyClass","applyTransition","lodash_es__WEBPACK_IMPORTED_MODULE_0__","lodash_es__WEBPACK_IMPORTED_MODULE_1__","g","v","children","length","e","escapeId","w","name","ID_DELIM","str","String","replace","dom","styleFn","attr","classFn","otherClasses","selection","graph","transition","CLONE_SYMBOLS_FLAG","lodash_es_clone","value","Object","_baseClone","write","json","options","directed","isDirected","multigraph","isMultigraph","compound","isCompound","nodes","writeNodes","edges","writeEdges","isUndefined","map","nodeValue","node","parent","edgeValue","edge","render","dagre_d3_es_src_dagre_index_js__WEBPACK_IMPORTED_MODULE_0__","dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__","_edges_f2ad444c_js__WEBPACK_IMPORTED_MODULE_2__","_mermaid_8af3addd_js__WEBPACK_IMPORTED_MODULE_3__","dagre_d3_es_src_graphlib_index_js__WEBPACK_IMPORTED_MODULE_4__","_createText_62fc7601_js__WEBPACK_IMPORTED_MODULE_5__","d3__WEBPACK_IMPORTED_MODULE_6__","clusterDb","descendants","parents","isDescendant","id","ancenstorId","trace","includes","copy","clusterId","newGraph","rootId","warn","push","forEach","data","info","setNode","setParent","debug","data2","edgeInCluster","setEdge","error","removeNode","extractDescendants","res","child","findNonClusterChild","_id","getAnchorId","externalConnections","extractor","depth","hasChildren","dir","rankdir","clusterData","clusterGraph","setGraph","nodesep","ranksep","marginx","marginy","setDefaultEdgeLabel","clusterNode","labelText","sorter","result","assign","sorted","shapes","rect","shapeSvg","insert","class","rect2","useHtmlLabels","flowchart","htmlLabels","label","text","labelType","style","labelStyle","appendChild","bbox","getBBox","div","dv","getBoundingClientRect","width","height","padding","halfPadding","diff","JSON","stringify","rx","ry","x","y","rectBox","intersect","point","roundedWithTitle","classes","innerRect","append","noteGroup","divider","clusterElems","recursiveRender","async","_elem","diagramtype","parentCluster","elem","clusters","edgePaths","edgeLabels","Promise","all","parse","o","newEl","sortNodesByHierarchy","shape","insertCluster","paths","n","type","markers","removeEdge","specialId","domId","edge1","structuredClone","edge2","arrowTypeEnd","fromCluster","toCluster","adjustClustersAndEdges","addHtmlLabel","_util_js__WEBPACK_IMPORTED_MODULE_0__","root","fo","html","client","methods_channel","color","channel","utils","lang","round","dist_color","flowStyles","flowRendererV2","conf","addVertices","vert","svgId","doc","diagObj","svg","select","concat","keys","vertex","classStr","join","styles","mermaid_8af3addd","vertexNode","vertexText","s","add_html_label","parentNode","removeChild","svgLabel","createElementNS","setAttribute","rows","split","lineBreakRegex","row","tspan","setAttributeNS","textContent","radious","_shape","link","linkTarget","tooltip","db","getTooltip","lookUpDomId","haveCallback","props","addEdges","defaultStyle","defaultLabelStyle","cnt","linkIdCnt","defaultStyles","linkIdBase","start","end","linkId","linkNameStart","linkNameEnd","edgeData","minlen","arrowhead","arrowTypeStart","stroke","thickness","pattern","interpolate","curve","src","defaultInterpolate","arrowheadStyle","labelpos","setConf","cnf","key","getClasses","draw","_version","getDirection","securityLevel","conf2","nodeSpacing","rankSpacing","sandboxElement","contentDocument","body","document","graphlib","subG","subGraphs","getSubGraphs","i2","addVertex","title","getVertices","getEdges","i","j","element","index_2c4b9a3b","insertTitle","titleTopMargin","getDiagramTitle","diagramPadding","useMaxWidth","indexNodes","labels","querySelectorAll","dim","insertBefore","firstChild","linkNode","fontFamily","nodeTextColor","textColor","titleColor","mainBkg","nodeBorder","arrowheadColor","lineColor","edgeLabelBackground","opacity","r","b","rgba","fade","clusterBkg","clusterBorder","tertiaryColor","border2","diagram","flowRenderer","parser","flowDb_1972c806","renderer","styles_080da4f6","init","arrowMarkerAbsolute","clear","setGen"],"mappings":"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","file":"static/js/10.19e1a0cc.chunk.js","sourcesContent":["import * as _ from 'lodash-es';\n\n// Public utility functions\nexport { isSubgraph, edgeToId, applyStyle, applyClass, applyTransition };\n\n/*\n * Returns true if the specified node in the graph is a subgraph node. A\n * subgraph node is one that contains other nodes.\n */\nfunction isSubgraph(g, v) {\n  return !!g.children(v).length;\n}\nfunction edgeToId(e) {\n  return escapeId(e.v) + ':' + escapeId(e.w) + ':' + escapeId(e.name);\n}\nvar ID_DELIM = /:/g;\nfunction escapeId(str) {\n  return str ? String(str).replace(ID_DELIM, '\\\\:') : '';\n}\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr('style', styleFn);\n  }\n}\nfunction applyClass(dom, classFn, otherClasses) {\n  if (classFn) {\n    dom.attr('class', classFn).attr('class', otherClasses + ' ' + dom.attr('class'));\n  }\n}\nfunction applyTransition(selection, g) {\n  var graph = g.graph();\n  if (_.isPlainObject(graph)) {\n    var transition = graph.transition;\n    if (_.isFunction(transition)) {\n      return transition(selection);\n    }\n  }\n  return selection;\n}","import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\nexport default clone;","import * as _ from 'lodash-es';\nimport { Graph } from './graph.js';\nexport { write, read };\nfunction write(g) {\n  var json = {\n    options: {\n      directed: g.isDirected(),\n      multigraph: g.isMultigraph(),\n      compound: g.isCompound()\n    },\n    nodes: writeNodes(g),\n    edges: writeEdges(g)\n  };\n  if (!_.isUndefined(g.graph())) {\n    json.value = _.clone(g.graph());\n  }\n  return json;\n}\nfunction writeNodes(g) {\n  return _.map(g.nodes(), function (v) {\n    var nodeValue = g.node(v);\n    var parent = g.parent(v);\n    var node = {\n      v: v\n    };\n    if (!_.isUndefined(nodeValue)) {\n      node.value = nodeValue;\n    }\n    if (!_.isUndefined(parent)) {\n      node.parent = parent;\n    }\n    return node;\n  });\n}\nfunction writeEdges(g) {\n  return _.map(g.edges(), function (e) {\n    var edgeValue = g.edge(e);\n    var edge = {\n      v: e.v,\n      w: e.w\n    };\n    if (!_.isUndefined(e.name)) {\n      edge.name = e.name;\n    }\n    if (!_.isUndefined(edgeValue)) {\n      edge.value = edgeValue;\n    }\n    return edge;\n  });\n}\nfunction read(json) {\n  var g = new Graph(json.options).setGraph(json.value);\n  _.each(json.nodes, function (entry) {\n    g.setNode(entry.v, entry.value);\n    if (entry.parent) {\n      g.setParent(entry.v, entry.parent);\n    }\n  });\n  _.each(json.edges, function (entry) {\n    g.setEdge({\n      v: entry.v,\n      w: entry.w,\n      name: entry.name\n    }, entry.value);\n  });\n  return g;\n}","import { layout } from \"dagre-d3-es/src/dagre/index.js\";\nimport * as graphlibJson from \"dagre-d3-es/src/graphlib/json.js\";\nimport { c as createLabel, i as intersectRect, a as insertMarkers, b as clear$2, d as clear$3, u as updateNodeBounds, s as setNodeElem, e as insertNode, f as insertEdgeLabel, p as positionNode, g as insertEdge, h as positionEdgeLabel } from \"./edges-f2ad444c.js\";\nimport { l as log, m as evaluate, c as getConfig } from \"./mermaid-8af3addd.js\";\nimport * as graphlib from \"dagre-d3-es/src/graphlib/index.js\";\nimport { a as createText } from \"./createText-62fc7601.js\";\nimport { select } from \"d3\";\nlet clusterDb = {};\nlet descendants = {};\nlet parents = {};\nconst clear$1 = () => {\n  descendants = {};\n  parents = {};\n  clusterDb = {};\n};\nconst isDescendant = (id, ancenstorId) => {\n  log.trace(\"In isDecendant\", ancenstorId, \" \", id, \" = \", descendants[ancenstorId].includes(id));\n  if (descendants[ancenstorId].includes(id)) {\n    return true;\n  }\n  return false;\n};\nconst edgeInCluster = (edge, clusterId) => {\n  log.info(\"Decendants of \", clusterId, \" is \", descendants[clusterId]);\n  log.info(\"Edge is \", edge);\n  if (edge.v === clusterId) {\n    return false;\n  }\n  if (edge.w === clusterId) {\n    return false;\n  }\n  if (!descendants[clusterId]) {\n    log.debug(\"Tilt, \", clusterId, \",not in decendants\");\n    return false;\n  }\n  return descendants[clusterId].includes(edge.v) || isDescendant(edge.v, clusterId) || isDescendant(edge.w, clusterId) || descendants[clusterId].includes(edge.w);\n};\nconst copy = (clusterId, graph, newGraph, rootId) => {\n  log.warn(\"Copying children of \", clusterId, \"root\", rootId, \"data\", graph.node(clusterId), rootId);\n  const nodes = graph.children(clusterId) || [];\n  if (clusterId !== rootId) {\n    nodes.push(clusterId);\n  }\n  log.warn(\"Copying (nodes) clusterId\", clusterId, \"nodes\", nodes);\n  nodes.forEach(node => {\n    if (graph.children(node).length > 0) {\n      copy(node, graph, newGraph, rootId);\n    } else {\n      const data = graph.node(node);\n      log.info(\"cp \", node, \" to \", rootId, \" with parent \", clusterId);\n      newGraph.setNode(node, data);\n      if (rootId !== graph.parent(node)) {\n        log.warn(\"Setting parent\", node, graph.parent(node));\n        newGraph.setParent(node, graph.parent(node));\n      }\n      if (clusterId !== rootId && node !== clusterId) {\n        log.debug(\"Setting parent\", node, clusterId);\n        newGraph.setParent(node, clusterId);\n      } else {\n        log.info(\"In copy \", clusterId, \"root\", rootId, \"data\", graph.node(clusterId), rootId);\n        log.debug(\"Not Setting parent for node=\", node, \"cluster!==rootId\", clusterId !== rootId, \"node!==clusterId\", node !== clusterId);\n      }\n      const edges = graph.edges(node);\n      log.debug(\"Copying Edges\", edges);\n      edges.forEach(edge => {\n        log.info(\"Edge\", edge);\n        const data2 = graph.edge(edge.v, edge.w, edge.name);\n        log.info(\"Edge data\", data2, rootId);\n        try {\n          if (edgeInCluster(edge, rootId)) {\n            log.info(\"Copying as \", edge.v, edge.w, data2, edge.name);\n            newGraph.setEdge(edge.v, edge.w, data2, edge.name);\n            log.info(\"newGraph edges \", newGraph.edges(), newGraph.edge(newGraph.edges()[0]));\n          } else {\n            log.info(\"Skipping copy of edge \", edge.v, \"-->\", edge.w, \" rootId: \", rootId, \" clusterId:\", clusterId);\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      });\n    }\n    log.debug(\"Removing node\", node);\n    graph.removeNode(node);\n  });\n};\nconst extractDescendants = (id, graph) => {\n  const children = graph.children(id);\n  let res = [...children];\n  for (const child of children) {\n    parents[child] = id;\n    res = [...res, ...extractDescendants(child, graph)];\n  }\n  return res;\n};\nconst findNonClusterChild = (id, graph) => {\n  log.trace(\"Searching\", id);\n  const children = graph.children(id);\n  log.trace(\"Searching children of id \", id, children);\n  if (children.length < 1) {\n    log.trace(\"This is a valid node\", id);\n    return id;\n  }\n  for (const child of children) {\n    const _id = findNonClusterChild(child, graph);\n    if (_id) {\n      log.trace(\"Found replacement for\", id, \" => \", _id);\n      return _id;\n    }\n  }\n};\nconst getAnchorId = id => {\n  if (!clusterDb[id]) {\n    return id;\n  }\n  if (!clusterDb[id].externalConnections) {\n    return id;\n  }\n  if (clusterDb[id]) {\n    return clusterDb[id].id;\n  }\n  return id;\n};\nconst adjustClustersAndEdges = (graph, depth) => {\n  if (!graph || depth > 10) {\n    log.debug(\"Opting out, no graph \");\n    return;\n  } else {\n    log.debug(\"Opting in, graph \");\n  }\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    if (children.length > 0) {\n      log.warn(\"Cluster identified\", id, \" Replacement id in edges: \", findNonClusterChild(id, graph));\n      descendants[id] = extractDescendants(id, graph);\n      clusterDb[id] = {\n        id: findNonClusterChild(id, graph),\n        clusterData: graph.node(id)\n      };\n    }\n  });\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    const edges = graph.edges();\n    if (children.length > 0) {\n      log.debug(\"Cluster identified\", id, descendants);\n      edges.forEach(edge => {\n        if (edge.v !== id && edge.w !== id) {\n          const d1 = isDescendant(edge.v, id);\n          const d2 = isDescendant(edge.w, id);\n          if (d1 ^ d2) {\n            log.warn(\"Edge: \", edge, \" leaves cluster \", id);\n            log.warn(\"Decendants of XXX \", id, \": \", descendants[id]);\n            clusterDb[id].externalConnections = true;\n          }\n        }\n      });\n    } else {\n      log.debug(\"Not a cluster \", id, descendants);\n    }\n  });\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.warn(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n    log.warn(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(graph.edge(e)));\n    let v = e.v;\n    let w = e.w;\n    log.warn(\"Fix XXX\", clusterDb, \"ids:\", e.v, e.w, \"Translating: \", clusterDb[e.v], \" --- \", clusterDb[e.w]);\n    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {\n      log.warn(\"Fixing and trixing link to self - removing XXX\", e.v, e.w, e.name);\n      log.warn(\"Fixing and trixing - removing XXX\", e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      const specialId = e.w + \"---\" + e.v;\n      graph.setNode(specialId, {\n        domId: specialId,\n        id: specialId,\n        labelStyle: \"\",\n        labelText: edge.label,\n        padding: 0,\n        shape: \"labelRect\",\n        style: \"\"\n      });\n      const edge1 = structuredClone(edge);\n      const edge2 = structuredClone(edge);\n      edge1.label = \"\";\n      edge1.arrowTypeEnd = \"none\";\n      edge2.label = \"\";\n      edge1.fromCluster = e.v;\n      edge2.toCluster = e.v;\n      graph.setEdge(v, specialId, edge1, e.name + \"-cyclic-special\");\n      graph.setEdge(specialId, w, edge2, e.name + \"-cyclic-special\");\n    } else if (clusterDb[e.v] || clusterDb[e.w]) {\n      log.warn(\"Fixing and trixing - removing XXX\", e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      if (v !== e.v) {\n        edge.fromCluster = e.v;\n      }\n      if (w !== e.w) {\n        edge.toCluster = e.w;\n      }\n      log.warn(\"Fix Replacing with XXX\", v, w, e.name);\n      graph.setEdge(v, w, edge, e.name);\n    }\n  });\n  log.warn(\"Adjusted Graph\", graphlibJson.write(graph));\n  extractor(graph, 0);\n  log.trace(clusterDb);\n};\nconst extractor = (graph, depth) => {\n  log.warn(\"extractor - \", depth, graphlibJson.write(graph), graph.children(\"D\"));\n  if (depth > 10) {\n    log.error(\"Bailing out\");\n    return;\n  }\n  let nodes = graph.nodes();\n  let hasChildren = false;\n  for (const node of nodes) {\n    const children = graph.children(node);\n    hasChildren = hasChildren || children.length > 0;\n  }\n  if (!hasChildren) {\n    log.debug(\"Done, no node has children\", graph.nodes());\n    return;\n  }\n  log.debug(\"Nodes = \", nodes, depth);\n  for (const node of nodes) {\n    log.debug(\"Extracting node\", node, clusterDb, clusterDb[node] && !clusterDb[node].externalConnections, !graph.parent(node), graph.node(node), graph.children(\"D\"), \" Depth \", depth);\n    if (!clusterDb[node]) {\n      log.debug(\"Not a cluster\", node, depth);\n    } else if (!clusterDb[node].externalConnections &&\n    // !graph.parent(node) &&\n    graph.children(node) && graph.children(node).length > 0) {\n      log.warn(\"Cluster without external connections, without a parent and with children\", node, depth);\n      const graphSettings = graph.graph();\n      let dir = graphSettings.rankdir === \"TB\" ? \"LR\" : \"TB\";\n      if (clusterDb[node] && clusterDb[node].clusterData && clusterDb[node].clusterData.dir) {\n        dir = clusterDb[node].clusterData.dir;\n        log.warn(\"Fixing dir\", clusterDb[node].clusterData.dir, dir);\n      }\n      const clusterGraph = new graphlib.Graph({\n        multigraph: true,\n        compound: true\n      }).setGraph({\n        rankdir: dir,\n        // Todo: set proper spacing\n        nodesep: 50,\n        ranksep: 50,\n        marginx: 8,\n        marginy: 8\n      }).setDefaultEdgeLabel(function () {\n        return {};\n      });\n      log.warn(\"Old graph before copy\", graphlibJson.write(graph));\n      copy(node, graph, clusterGraph, node);\n      graph.setNode(node, {\n        clusterNode: true,\n        id: node,\n        clusterData: clusterDb[node].clusterData,\n        labelText: clusterDb[node].labelText,\n        graph: clusterGraph\n      });\n      log.warn(\"New graph after copy node: (\", node, \")\", graphlibJson.write(clusterGraph));\n      log.debug(\"Old graph after copy\", graphlibJson.write(graph));\n    } else {\n      log.warn(\"Cluster ** \", node, \" **not meeting the criteria !externalConnections:\", !clusterDb[node].externalConnections, \" no parent: \", !graph.parent(node), \" children \", graph.children(node) && graph.children(node).length > 0, graph.children(\"D\"), depth);\n      log.debug(clusterDb);\n    }\n  }\n  nodes = graph.nodes();\n  log.warn(\"New list of nodes\", nodes);\n  for (const node of nodes) {\n    const data = graph.node(node);\n    log.warn(\" Now next level\", node, data);\n    if (data.clusterNode) {\n      extractor(data.graph, depth + 1);\n    }\n  }\n};\nconst sorter = (graph, nodes) => {\n  if (nodes.length === 0) {\n    return [];\n  }\n  let result = Object.assign(nodes);\n  nodes.forEach(node => {\n    const children = graph.children(node);\n    const sorted = sorter(graph, children);\n    result = [...result, ...sorted];\n  });\n  return result;\n};\nconst sortNodesByHierarchy = graph => sorter(graph, graph.children());\nconst rect = (parent, node) => {\n  log.info(\"Creating subgraph rect for \", node.id, node);\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"cluster\" + (node.class ? \" \" + node.class : \"\")).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const useHtmlLabels = evaluate(getConfig().flowchart.htmlLabels);\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"cluster-label\");\n  const text = node.labelType === \"markdown\" ? createText(label, node.labelText, {\n    style: node.labelStyle,\n    useHtmlLabels\n  }) : label.node().appendChild(createLabel(node.labelText, node.labelStyle, void 0, true));\n  let bbox = text.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;\n  if (node.width <= bbox.width + padding) {\n    node.diff = (bbox.width - node.width) / 2 - node.padding / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n  log.trace(\"Data \", node, JSON.stringify(node));\n  rect2.attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", node.x - width / 2).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", width).attr(\"height\", node.height + padding);\n  if (useHtmlLabels) {\n    label.attr(\"transform\",\n    // This puts the labal on top of the box instead of inside it\n    \"translate(\" + (node.x - bbox.width / 2) + \", \" + (node.y - node.height / 2) + \")\");\n  } else {\n    label.attr(\"transform\",\n    // This puts the labal on top of the box instead of inside it\n    \"translate(\" + node.x + \", \" + (node.y - node.height / 2) + \")\");\n  }\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst noteGroup = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"note-cluster\").attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  rect2.attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", node.x - node.width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", node.width + padding).attr(\"height\", node.height + padding).attr(\"fill\", \"none\");\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst roundedWithTitle = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", node.classes).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"cluster-label\");\n  const innerRect = shapeSvg.append(\"rect\");\n  const text = label.node().appendChild(createLabel(node.labelText, node.labelStyle, void 0, true));\n  let bbox = text.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  bbox = text.getBBox();\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;\n  if (node.width <= bbox.width + node.padding) {\n    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n  rect2.attr(\"class\", \"outer\").attr(\"x\", node.x - width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", width + padding).attr(\"height\", node.height + padding);\n  innerRect.attr(\"class\", \"inner\").attr(\"x\", node.x - width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding + bbox.height - 1).attr(\"width\", width + padding).attr(\"height\", node.height + padding - bbox.height - 3);\n  label.attr(\"transform\", \"translate(\" + (node.x - bbox.width / 2) + \", \" + (node.y - node.height / 2 - node.padding / 3 + (evaluate(getConfig().flowchart.htmlLabels) ? 5 : 3)) + \")\");\n  const rectBox = rect2.node().getBBox();\n  node.height = rectBox.height;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst divider = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", node.classes).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  rect2.attr(\"class\", \"divider\").attr(\"x\", node.x - node.width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2).attr(\"width\", node.width + padding).attr(\"height\", node.height + padding);\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.diff = -node.padding / 2;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst shapes = {\n  rect,\n  roundedWithTitle,\n  noteGroup,\n  divider\n};\nlet clusterElems = {};\nconst insertCluster = (elem, node) => {\n  log.trace(\"Inserting cluster\");\n  const shape = node.shape || \"rect\";\n  clusterElems[node.id] = shapes[shape](elem, node);\n};\nconst clear = () => {\n  clusterElems = {};\n};\nconst recursiveRender = async (_elem, graph, diagramtype, id, parentCluster) => {\n  log.info(\"Graph in recursive render: XXX\", graphlibJson.write(graph), parentCluster);\n  const dir = graph.graph().rankdir;\n  log.trace(\"Dir in recursive render - dir:\", dir);\n  const elem = _elem.insert(\"g\").attr(\"class\", \"root\");\n  if (!graph.nodes()) {\n    log.info(\"No nodes found for\", graph);\n  } else {\n    log.info(\"Recursive render XXX\", graph.nodes());\n  }\n  if (graph.edges().length > 0) {\n    log.trace(\"Recursive edges\", graph.edge(graph.edges()[0]));\n  }\n  const clusters = elem.insert(\"g\").attr(\"class\", \"clusters\");\n  const edgePaths = elem.insert(\"g\").attr(\"class\", \"edgePaths\");\n  const edgeLabels = elem.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  const nodes = elem.insert(\"g\").attr(\"class\", \"nodes\");\n  await Promise.all(graph.nodes().map(async function (v) {\n    const node = graph.node(v);\n    if (parentCluster !== void 0) {\n      const data = JSON.parse(JSON.stringify(parentCluster.clusterData));\n      log.info(\"Setting data for cluster XXX (\", v, \") \", data, parentCluster);\n      graph.setNode(parentCluster.id, data);\n      if (!graph.parent(v)) {\n        log.trace(\"Setting parent\", v, parentCluster.id);\n        graph.setParent(v, parentCluster.id, data);\n      }\n    }\n    log.info(\"(Insert) Node XXX\" + v + \": \" + JSON.stringify(graph.node(v)));\n    if (node && node.clusterNode) {\n      log.info(\"Cluster identified\", v, node.width, graph.node(v));\n      const o = await recursiveRender(nodes, node.graph, diagramtype, id, graph.node(v));\n      const newEl = o.elem;\n      updateNodeBounds(node, newEl);\n      node.diff = o.diff || 0;\n      log.info(\"Node bounds (abc123)\", v, node, node.width, node.x, node.y);\n      setNodeElem(newEl, node);\n      log.warn(\"Recursive render complete \", newEl, node);\n    } else {\n      if (graph.children(v).length > 0) {\n        log.info(\"Cluster - the non recursive path XXX\", v, node.id, node, graph);\n        log.info(findNonClusterChild(node.id, graph));\n        clusterDb[node.id] = {\n          id: findNonClusterChild(node.id, graph),\n          node\n        };\n      } else {\n        log.info(\"Node - the non recursive path\", v, node.id, node);\n        await insertNode(nodes, graph.node(v), dir);\n      }\n    }\n  }));\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e.v, e.w, e.name);\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \", e, \" \", JSON.stringify(graph.edge(e)));\n    log.info(\"Fix\", clusterDb, \"ids:\", e.v, e.w, \"Translateing: \", clusterDb[e.v], clusterDb[e.w]);\n    insertEdgeLabel(edgeLabels, edge);\n  });\n  graph.edges().forEach(function (e) {\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n  });\n  log.info(\"#############################################\");\n  log.info(\"###                Layout                 ###\");\n  log.info(\"#############################################\");\n  log.info(graph);\n  layout(graph);\n  log.info(\"Graph after layout:\", graphlibJson.write(graph));\n  let diff = 0;\n  sortNodesByHierarchy(graph).forEach(function (v) {\n    const node = graph.node(v);\n    log.info(\"Position \" + v + \": \" + JSON.stringify(graph.node(v)));\n    log.info(\"Position \" + v + \": (\" + node.x, \",\" + node.y, \") width: \", node.width, \" height: \", node.height);\n    if (node && node.clusterNode) {\n      positionNode(node);\n    } else {\n      if (graph.children(v).length > 0) {\n        insertCluster(clusters, node);\n        clusterDb[node.id].node = node;\n      } else {\n        positionNode(node);\n      }\n    }\n  });\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(edge), edge);\n    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph, id);\n    positionEdgeLabel(edge, paths);\n  });\n  graph.nodes().forEach(function (v) {\n    const n = graph.node(v);\n    log.info(v, n.type, n.diff);\n    if (n.type === \"group\") {\n      diff = n.diff;\n    }\n  });\n  return {\n    elem,\n    diff\n  };\n};\nconst render = async (elem, graph, markers, diagramtype, id) => {\n  insertMarkers(elem, markers, diagramtype, id);\n  clear$2();\n  clear$3();\n  clear();\n  clear$1();\n  log.warn(\"Graph at first:\", JSON.stringify(graphlibJson.write(graph)));\n  adjustClustersAndEdges(graph);\n  log.warn(\"Graph after:\", JSON.stringify(graphlibJson.write(graph)));\n  await recursiveRender(elem, graph, diagramtype, id);\n};\nexport { render as r };","import * as util from '../util.js';\nexport { addHtmlLabel };\nfunction addHtmlLabel(root, node) {\n  var fo = root.append('foreignObject').attr('width', '100000');\n  var div = fo.append('xhtml:div');\n  div.attr('xmlns', 'http://www.w3.org/1999/xhtml');\n  var label = node.label;\n  switch (typeof label) {\n    case 'function':\n      div.insert(label);\n      break;\n    case 'object':\n      // Currently we assume this is a DOM object.\n      div.insert(function () {\n        return label;\n      });\n      break;\n    default:\n      div.html(label);\n  }\n  util.applyStyle(div, node.labelStyle);\n  div.style('display', 'inline-block');\n  // Fix for firefox\n  div.style('white-space', 'nowrap');\n  var client = div.node().getBoundingClientRect();\n  fo.attr('width', client.width).attr('height', client.height);\n  return fo;\n}","/* IMPORT */\nimport _ from '../utils/index.js';\nimport Color from '../color/index.js';\n/* MAIN */\nconst channel = (color, channel) => {\n  return _.lang.round(Color.parse(color)[channel]);\n};\n/* EXPORT */\nexport default channel;","import * as graphlib from \"dagre-d3-es/src/graphlib/index.js\";\nimport { curveLinear, select, selectAll } from \"d3\";\nimport { k as getStylesFromArray, l as log, m as evaluate, c as getConfig, e as common, n as interpolateToCurve, u as utils, o as setupGraphViewbox } from \"./mermaid-8af3addd.js\";\nimport { r as render } from \"./index-2c4b9a3b.js\";\nimport { addHtmlLabel } from \"dagre-d3-es/src/dagre-js/label/add-html-label.js\";\nimport * as khroma from \"khroma\";\nconst conf = {};\nconst setConf = function (cnf) {\n  const keys = Object.keys(cnf);\n  for (const key of keys) {\n    conf[key] = cnf[key];\n  }\n};\nconst addVertices = function (vert, g, svgId, root, doc, diagObj) {\n  const svg = root.select(\"[id=\\\"\".concat(svgId, \"\\\"]\"));\n  const keys = Object.keys(vert);\n  keys.forEach(function (id) {\n    const vertex = vert[id];\n    let classStr = \"default\";\n    if (vertex.classes.length > 0) {\n      classStr = vertex.classes.join(\" \");\n    }\n    classStr = classStr + \" flowchart-label\";\n    const styles = getStylesFromArray(vertex.styles);\n    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;\n    let vertexNode;\n    log.info(\"vertex\", vertex, vertex.labelType);\n    if (vertex.labelType === \"markdown\") {\n      log.info(\"vertex\", vertex, vertex.labelType);\n    } else {\n      if (evaluate(getConfig().flowchart.htmlLabels)) {\n        const node = {\n          label: vertexText.replace(/fa[blrs]?:fa-[\\w-]+/g, s => \"<i class='\".concat(s.replace(\":\", \" \"), \"'></i>\"))\n        };\n        vertexNode = addHtmlLabel(svg, node).node();\n        vertexNode.parentNode.removeChild(vertexNode);\n      } else {\n        const svgLabel = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n        svgLabel.setAttribute(\"style\", styles.labelStyle.replace(\"color:\", \"fill:\"));\n        const rows = vertexText.split(common.lineBreakRegex);\n        for (const row of rows) {\n          const tspan = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n          tspan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n          tspan.setAttribute(\"dy\", \"1em\");\n          tspan.setAttribute(\"x\", \"1\");\n          tspan.textContent = row;\n          svgLabel.appendChild(tspan);\n        }\n        vertexNode = svgLabel;\n      }\n    }\n    let radious = 0;\n    let _shape = \"\";\n    switch (vertex.type) {\n      case \"round\":\n        radious = 5;\n        _shape = \"rect\";\n        break;\n      case \"square\":\n        _shape = \"rect\";\n        break;\n      case \"diamond\":\n        _shape = \"question\";\n        break;\n      case \"hexagon\":\n        _shape = \"hexagon\";\n        break;\n      case \"odd\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n      case \"lean_right\":\n        _shape = \"lean_right\";\n        break;\n      case \"lean_left\":\n        _shape = \"lean_left\";\n        break;\n      case \"trapezoid\":\n        _shape = \"trapezoid\";\n        break;\n      case \"inv_trapezoid\":\n        _shape = \"inv_trapezoid\";\n        break;\n      case \"odd_right\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n      case \"circle\":\n        _shape = \"circle\";\n        break;\n      case \"ellipse\":\n        _shape = \"ellipse\";\n        break;\n      case \"stadium\":\n        _shape = \"stadium\";\n        break;\n      case \"subroutine\":\n        _shape = \"subroutine\";\n        break;\n      case \"cylinder\":\n        _shape = \"cylinder\";\n        break;\n      case \"group\":\n        _shape = \"rect\";\n        break;\n      case \"doublecircle\":\n        _shape = \"doublecircle\";\n        break;\n      default:\n        _shape = \"rect\";\n    }\n    g.setNode(vertex.id, {\n      labelStyle: styles.labelStyle,\n      shape: _shape,\n      labelText: vertexText,\n      labelType: vertex.labelType,\n      rx: radious,\n      ry: radious,\n      class: classStr,\n      style: styles.style,\n      id: vertex.id,\n      link: vertex.link,\n      linkTarget: vertex.linkTarget,\n      tooltip: diagObj.db.getTooltip(vertex.id) || \"\",\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      haveCallback: vertex.haveCallback,\n      width: vertex.type === \"group\" ? 500 : void 0,\n      dir: vertex.dir,\n      type: vertex.type,\n      props: vertex.props,\n      padding: getConfig().flowchart.padding\n    });\n    log.info(\"setNode\", {\n      labelStyle: styles.labelStyle,\n      labelType: vertex.labelType,\n      shape: _shape,\n      labelText: vertexText,\n      rx: radious,\n      ry: radious,\n      class: classStr,\n      style: styles.style,\n      id: vertex.id,\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      width: vertex.type === \"group\" ? 500 : void 0,\n      type: vertex.type,\n      dir: vertex.dir,\n      props: vertex.props,\n      padding: getConfig().flowchart.padding\n    });\n  });\n};\nconst addEdges = function (edges, g, diagObj) {\n  log.info(\"abc78 edges = \", edges);\n  let cnt = 0;\n  let linkIdCnt = {};\n  let defaultStyle;\n  let defaultLabelStyle;\n  if (edges.defaultStyle !== void 0) {\n    const defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n  edges.forEach(function (edge) {\n    cnt++;\n    const linkIdBase = \"L-\" + edge.start + \"-\" + edge.end;\n    if (linkIdCnt[linkIdBase] === void 0) {\n      linkIdCnt[linkIdBase] = 0;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    } else {\n      linkIdCnt[linkIdBase]++;\n      log.info(\"abc78 new entry\", linkIdBase, linkIdCnt[linkIdBase]);\n    }\n    let linkId = linkIdBase + \"-\" + linkIdCnt[linkIdBase];\n    log.info(\"abc78 new link id to be used is\", linkIdBase, linkId, linkIdCnt[linkIdBase]);\n    const linkNameStart = \"LS-\" + edge.start;\n    const linkNameEnd = \"LE-\" + edge.end;\n    const edgeData = {\n      style: \"\",\n      labelStyle: \"\"\n    };\n    edgeData.minlen = edge.length || 1;\n    if (edge.type === \"arrow_open\") {\n      edgeData.arrowhead = \"none\";\n    } else {\n      edgeData.arrowhead = \"normal\";\n    }\n    edgeData.arrowTypeStart = \"arrow_open\";\n    edgeData.arrowTypeEnd = \"arrow_open\";\n    switch (edge.type) {\n      case \"double_arrow_cross\":\n        edgeData.arrowTypeStart = \"arrow_cross\";\n      case \"arrow_cross\":\n        edgeData.arrowTypeEnd = \"arrow_cross\";\n        break;\n      case \"double_arrow_point\":\n        edgeData.arrowTypeStart = \"arrow_point\";\n      case \"arrow_point\":\n        edgeData.arrowTypeEnd = \"arrow_point\";\n        break;\n      case \"double_arrow_circle\":\n        edgeData.arrowTypeStart = \"arrow_circle\";\n      case \"arrow_circle\":\n        edgeData.arrowTypeEnd = \"arrow_circle\";\n        break;\n    }\n    let style = \"\";\n    let labelStyle = \"\";\n    switch (edge.stroke) {\n      case \"normal\":\n        style = \"fill:none;\";\n        if (defaultStyle !== void 0) {\n          style = defaultStyle;\n        }\n        if (defaultLabelStyle !== void 0) {\n          labelStyle = defaultLabelStyle;\n        }\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"solid\";\n        break;\n      case \"dotted\":\n        edgeData.thickness = \"normal\";\n        edgeData.pattern = \"dotted\";\n        edgeData.style = \"fill:none;stroke-width:2px;stroke-dasharray:3;\";\n        break;\n      case \"thick\":\n        edgeData.thickness = \"thick\";\n        edgeData.pattern = \"solid\";\n        edgeData.style = \"stroke-width: 3.5px;fill:none;\";\n        break;\n      case \"invisible\":\n        edgeData.thickness = \"invisible\";\n        edgeData.pattern = \"solid\";\n        edgeData.style = \"stroke-width: 0;fill:none;\";\n        break;\n    }\n    if (edge.style !== void 0) {\n      const styles = getStylesFromArray(edge.style);\n      style = styles.style;\n      labelStyle = styles.labelStyle;\n    }\n    edgeData.style = edgeData.style += style;\n    edgeData.labelStyle = edgeData.labelStyle += labelStyle;\n    if (edge.interpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n    if (edge.text === void 0) {\n      if (edge.style !== void 0) {\n        edgeData.arrowheadStyle = \"fill: #333\";\n      }\n    } else {\n      edgeData.arrowheadStyle = \"fill: #333\";\n      edgeData.labelpos = \"c\";\n    }\n    edgeData.labelType = edge.labelType;\n    edgeData.label = edge.text.replace(common.lineBreakRegex, \"\\n\");\n    if (edge.style === void 0) {\n      edgeData.style = edgeData.style || \"stroke: #333; stroke-width: 1.5px;fill:none;\";\n    }\n    edgeData.labelStyle = edgeData.labelStyle.replace(\"color:\", \"fill:\");\n    edgeData.id = linkId;\n    edgeData.classes = \"flowchart-link \" + linkNameStart + \" \" + linkNameEnd;\n    g.setEdge(edge.start, edge.end, edgeData, cnt);\n  });\n};\nconst getClasses = function (text, diagObj) {\n  return diagObj.db.getClasses();\n};\nconst draw = async function (text, id, _version, diagObj) {\n  log.info(\"Drawing flowchart\");\n  let dir = diagObj.db.getDirection();\n  if (dir === void 0) {\n    dir = \"TD\";\n  }\n  const {\n    securityLevel,\n    flowchart: conf2\n  } = getConfig();\n  const nodeSpacing = conf2.nodeSpacing || 50;\n  const rankSpacing = conf2.rankSpacing || 50;\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const doc = securityLevel === \"sandbox\" ? sandboxElement.nodes()[0].contentDocument : document;\n  const g = new graphlib.Graph({\n    multigraph: true,\n    compound: true\n  }).setGraph({\n    rankdir: dir,\n    nodesep: nodeSpacing,\n    ranksep: rankSpacing,\n    marginx: 0,\n    marginy: 0\n  }).setDefaultEdgeLabel(function () {\n    return {};\n  });\n  let subG;\n  const subGraphs = diagObj.db.getSubGraphs();\n  log.info(\"Subgraphs - \", subGraphs);\n  for (let i2 = subGraphs.length - 1; i2 >= 0; i2--) {\n    subG = subGraphs[i2];\n    log.info(\"Subgraph - \", subG);\n    diagObj.db.addVertex(subG.id, {\n      text: subG.title,\n      type: subG.labelType\n    }, \"group\", void 0, subG.classes, subG.dir);\n  }\n  const vert = diagObj.db.getVertices();\n  const edges = diagObj.db.getEdges();\n  log.info(\"Edges\", edges);\n  let i = 0;\n  for (i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    selectAll(\"cluster\").append(\"text\");\n    for (let j = 0; j < subG.nodes.length; j++) {\n      log.info(\"Setting up subgraphs\", subG.nodes[j], subG.id);\n      g.setParent(subG.nodes[j], subG.id);\n    }\n  }\n  addVertices(vert, g, id, root, doc, diagObj);\n  addEdges(edges, g);\n  const svg = root.select(\"[id=\\\"\".concat(id, \"\\\"]\"));\n  const element = root.select(\"#\" + id + \" g\");\n  await render(element, g, [\"point\", \"circle\", \"cross\"], \"flowchart\", id);\n  utils.insertTitle(svg, \"flowchartTitleText\", conf2.titleTopMargin, diagObj.db.getDiagramTitle());\n  setupGraphViewbox(g, svg, conf2.diagramPadding, conf2.useMaxWidth);\n  diagObj.db.indexNodes(\"subGraph\" + i);\n  if (!conf2.htmlLabels) {\n    const labels = doc.querySelectorAll('[id=\"' + id + '\"] .edgeLabel .label');\n    for (const label of labels) {\n      const dim = label.getBBox();\n      const rect = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n      rect.setAttribute(\"rx\", 0);\n      rect.setAttribute(\"ry\", 0);\n      rect.setAttribute(\"width\", dim.width);\n      rect.setAttribute(\"height\", dim.height);\n      label.insertBefore(rect, label.firstChild);\n    }\n  }\n  const keys = Object.keys(vert);\n  keys.forEach(function (key) {\n    const vertex = vert[key];\n    if (vertex.link) {\n      const node = select(\"#\" + id + ' [id=\"' + key + '\"]');\n      if (node) {\n        const link = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"a\");\n        link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"class\", vertex.classes.join(\" \"));\n        link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"href\", vertex.link);\n        link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"rel\", \"noopener\");\n        if (securityLevel === \"sandbox\") {\n          link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"target\", \"_top\");\n        } else if (vertex.linkTarget) {\n          link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"target\", vertex.linkTarget);\n        }\n        const linkNode = node.insert(function () {\n          return link;\n        }, \":first-child\");\n        const shape = node.select(\".label-container\");\n        if (shape) {\n          linkNode.append(function () {\n            return shape.node();\n          });\n        }\n        const label = node.select(\".label\");\n        if (label) {\n          linkNode.append(function () {\n            return label.node();\n          });\n        }\n      }\n    }\n  });\n};\nconst flowRendererV2 = {\n  setConf,\n  addVertices,\n  addEdges,\n  getClasses,\n  draw\n};\nconst fade = (color, opacity) => {\n  const channel = khroma.channel;\n  const r = channel(color, \"r\");\n  const g = channel(color, \"g\");\n  const b = channel(color, \"b\");\n  return khroma.rgba(r, g, b, opacity);\n};\nconst getStyles = options => \".label {\\n    font-family: \".concat(options.fontFamily, \";\\n    color: \").concat(options.nodeTextColor || options.textColor, \";\\n  }\\n  .cluster-label text {\\n    fill: \").concat(options.titleColor, \";\\n  }\\n  .cluster-label span,p {\\n    color: \").concat(options.titleColor, \";\\n  }\\n\\n  .label text,span,p {\\n    fill: \").concat(options.nodeTextColor || options.textColor, \";\\n    color: \").concat(options.nodeTextColor || options.textColor, \";\\n  }\\n\\n  .node rect,\\n  .node circle,\\n  .node ellipse,\\n  .node polygon,\\n  .node path {\\n    fill: \").concat(options.mainBkg, \";\\n    stroke: \").concat(options.nodeBorder, \";\\n    stroke-width: 1px;\\n  }\\n  .flowchart-label text {\\n    text-anchor: middle;\\n  }\\n  // .flowchart-label .text-outer-tspan {\\n  //   text-anchor: middle;\\n  // }\\n  // .flowchart-label .text-inner-tspan {\\n  //   text-anchor: start;\\n  // }\\n\\n  .node .label {\\n    text-align: center;\\n  }\\n  .node.clickable {\\n    cursor: pointer;\\n  }\\n\\n  .arrowheadPath {\\n    fill: \").concat(options.arrowheadColor, \";\\n  }\\n\\n  .edgePath .path {\\n    stroke: \").concat(options.lineColor, \";\\n    stroke-width: 2.0px;\\n  }\\n\\n  .flowchart-link {\\n    stroke: \").concat(options.lineColor, \";\\n    fill: none;\\n  }\\n\\n  .edgeLabel {\\n    background-color: \").concat(options.edgeLabelBackground, \";\\n    rect {\\n      opacity: 0.5;\\n      background-color: \").concat(options.edgeLabelBackground, \";\\n      fill: \").concat(options.edgeLabelBackground, \";\\n    }\\n    text-align: center;\\n  }\\n\\n  /* For html labels only */\\n  .labelBkg {\\n    background-color: \").concat(fade(options.edgeLabelBackground, 0.5), \";\\n    // background-color: \\n  }\\n\\n  .cluster rect {\\n    fill: \").concat(options.clusterBkg, \";\\n    stroke: \").concat(options.clusterBorder, \";\\n    stroke-width: 1px;\\n  }\\n\\n  .cluster text {\\n    fill: \").concat(options.titleColor, \";\\n  }\\n\\n  .cluster span,p {\\n    color: \").concat(options.titleColor, \";\\n  }\\n  /* .cluster div {\\n    color: \").concat(options.titleColor, \";\\n  } */\\n\\n  div.mermaidTooltip {\\n    position: absolute;\\n    text-align: center;\\n    max-width: 200px;\\n    padding: 2px;\\n    font-family: \").concat(options.fontFamily, \";\\n    font-size: 12px;\\n    background: \").concat(options.tertiaryColor, \";\\n    border: 1px solid \").concat(options.border2, \";\\n    border-radius: 2px;\\n    pointer-events: none;\\n    z-index: 100;\\n  }\\n\\n  .flowchartTitleText {\\n    text-anchor: middle;\\n    font-size: 18px;\\n    fill: \").concat(options.textColor, \";\\n  }\\n\");\nconst flowStyles = getStyles;\nexport { flowStyles as a, flowRendererV2 as f };","import * as d3 from 'd3';\nimport * as _ from 'lodash-es';\nimport { layout } from '../dagre/index.js';\nimport { arrows, setArrows } from './arrows.js';\nimport { createClusters, setCreateClusters } from './create-clusters.js';\nimport { createEdgeLabels, setCreateEdgeLabels } from './create-edge-labels.js';\nimport { createEdgePaths, setCreateEdgePaths } from './create-edge-paths.js';\nimport { createNodes, setCreateNodes } from './create-nodes.js';\nimport { positionClusters } from './position-clusters.js';\nimport { positionEdgeLabels } from './position-edge-labels.js';\nimport { positionNodes } from './position-nodes.js';\nimport { shapes, setShapes } from './shapes.js';\nexport { render };\n\n// This design is based on http://bost.ocks.org/mike/chart/.\nfunction render() {\n  var fn = function (svg, g) {\n    preProcessGraph(g);\n    var outputGroup = createOrSelectGroup(svg, 'output');\n    var clustersGroup = createOrSelectGroup(outputGroup, 'clusters');\n    var edgePathsGroup = createOrSelectGroup(outputGroup, 'edgePaths');\n    var edgeLabels = createEdgeLabels(createOrSelectGroup(outputGroup, 'edgeLabels'), g);\n    var nodes = createNodes(createOrSelectGroup(outputGroup, 'nodes'), g, shapes);\n    layout(g);\n    positionNodes(nodes, g);\n    positionEdgeLabels(edgeLabels, g);\n    createEdgePaths(edgePathsGroup, g, arrows);\n    var clusters = createClusters(clustersGroup, g);\n    positionClusters(clusters, g);\n    postProcessGraph(g);\n  };\n  fn.createNodes = function (value) {\n    if (!arguments.length) return createNodes;\n    setCreateNodes(value);\n    return fn;\n  };\n  fn.createClusters = function (value) {\n    if (!arguments.length) return createClusters;\n    setCreateClusters(value);\n    return fn;\n  };\n  fn.createEdgeLabels = function (value) {\n    if (!arguments.length) return createEdgeLabels;\n    setCreateEdgeLabels(value);\n    return fn;\n  };\n  fn.createEdgePaths = function (value) {\n    if (!arguments.length) return createEdgePaths;\n    setCreateEdgePaths(value);\n    return fn;\n  };\n  fn.shapes = function (value) {\n    if (!arguments.length) return shapes;\n    setShapes(value);\n    return fn;\n  };\n  fn.arrows = function (value) {\n    if (!arguments.length) return arrows;\n    setArrows(value);\n    return fn;\n  };\n  return fn;\n}\nvar NODE_DEFAULT_ATTRS = {\n  paddingLeft: 10,\n  paddingRight: 10,\n  paddingTop: 10,\n  paddingBottom: 10,\n  rx: 0,\n  ry: 0,\n  shape: 'rect'\n};\nvar EDGE_DEFAULT_ATTRS = {\n  arrowhead: 'normal',\n  curve: d3.curveLinear\n};\nfunction preProcessGraph(g) {\n  g.nodes().forEach(function (v) {\n    var node = g.node(v);\n    if (!_.has(node, 'label') && !g.children(v).length) {\n      node.label = v;\n    }\n    if (_.has(node, 'paddingX')) {\n      _.defaults(node, {\n        paddingLeft: node.paddingX,\n        paddingRight: node.paddingX\n      });\n    }\n    if (_.has(node, 'paddingY')) {\n      _.defaults(node, {\n        paddingTop: node.paddingY,\n        paddingBottom: node.paddingY\n      });\n    }\n    if (_.has(node, 'padding')) {\n      _.defaults(node, {\n        paddingLeft: node.padding,\n        paddingRight: node.padding,\n        paddingTop: node.padding,\n        paddingBottom: node.padding\n      });\n    }\n    _.defaults(node, NODE_DEFAULT_ATTRS);\n    _.each(['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'], function (k) {\n      node[k] = Number(node[k]);\n    });\n\n    // Save dimensions for restore during post-processing\n    if (_.has(node, 'width')) {\n      node._prevWidth = node.width;\n    }\n    if (_.has(node, 'height')) {\n      node._prevHeight = node.height;\n    }\n  });\n  g.edges().forEach(function (e) {\n    var edge = g.edge(e);\n    if (!_.has(edge, 'label')) {\n      edge.label = '';\n    }\n    _.defaults(edge, EDGE_DEFAULT_ATTRS);\n  });\n}\nfunction postProcessGraph(g) {\n  _.each(g.nodes(), function (v) {\n    var node = g.node(v);\n\n    // Restore original dimensions\n    if (_.has(node, '_prevWidth')) {\n      node.width = node._prevWidth;\n    } else {\n      delete node.width;\n    }\n    if (_.has(node, '_prevHeight')) {\n      node.height = node._prevHeight;\n    } else {\n      delete node.height;\n    }\n    delete node._prevWidth;\n    delete node._prevHeight;\n  });\n}\nfunction createOrSelectGroup(root, name) {\n  var selection = root.select('g.' + name);\n  if (selection.empty()) {\n    selection = root.append('g').attr('class', name);\n  }\n  return selection;\n}","import { p as parser, f as flowDb } from \"./flowDb-1972c806.js\";\nimport * as graphlib from \"dagre-d3-es/src/graphlib/index.js\";\nimport { select, curveLinear, selectAll } from \"d3\";\nimport { k as getStylesFromArray, m as evaluate, c as getConfig, e as common, l as log, n as interpolateToCurve, o as setupGraphViewbox } from \"./mermaid-8af3addd.js\";\nimport { render } from \"dagre-d3-es\";\nimport { applyStyle } from \"dagre-d3-es/src/dagre-js/util.js\";\nimport { addHtmlLabel } from \"dagre-d3-es/src/dagre-js/label/add-html-label.js\";\nimport { intersectPolygon } from \"dagre-d3-es/src/dagre-js/intersect/intersect-polygon.js\";\nimport { intersectRect } from \"dagre-d3-es/src/dagre-js/intersect/intersect-rect.js\";\nimport { f as flowRendererV2, a as flowStyles } from \"./styles-080da4f6.js\";\nimport \"ts-dedent\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"lodash-es/merge.js\";\nimport \"stylis\";\nimport \"lodash-es/isEmpty.js\";\nimport \"./index-2c4b9a3b.js\";\nimport \"dagre-d3-es/src/dagre/index.js\";\nimport \"dagre-d3-es/src/graphlib/json.js\";\nimport \"./edges-f2ad444c.js\";\nimport \"./createText-62fc7601.js\";\nimport \"mdast-util-from-markdown\";\nfunction question(parent, bbox, node) {\n  const w = bbox.width;\n  const h = bbox.height;\n  const s = (w + h) * 0.9;\n  const points = [{\n    x: s / 2,\n    y: 0\n  }, {\n    x: s,\n    y: -s / 2\n  }, {\n    x: s / 2,\n    y: -s\n  }, {\n    x: 0,\n    y: -s / 2\n  }];\n  const shapeSvg = insertPolygonShape(parent, s, s, points);\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n  return shapeSvg;\n}\nfunction hexagon(parent, bbox, node) {\n  const f = 4;\n  const h = bbox.height;\n  const m = h / f;\n  const w = bbox.width + 2 * m;\n  const points = [{\n    x: m,\n    y: 0\n  }, {\n    x: w - m,\n    y: 0\n  }, {\n    x: w,\n    y: -h / 2\n  }, {\n    x: w - m,\n    y: -h\n  }, {\n    x: m,\n    y: -h\n  }, {\n    x: 0,\n    y: -h / 2\n  }];\n  const shapeSvg = insertPolygonShape(parent, w, h, points);\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n  return shapeSvg;\n}\nfunction rect_left_inv_arrow(parent, bbox, node) {\n  const w = bbox.width;\n  const h = bbox.height;\n  const points = [{\n    x: -h / 2,\n    y: 0\n  }, {\n    x: w,\n    y: 0\n  }, {\n    x: w,\n    y: -h\n  }, {\n    x: -h / 2,\n    y: -h\n  }, {\n    x: 0,\n    y: -h / 2\n  }];\n  const shapeSvg = insertPolygonShape(parent, w, h, points);\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n  return shapeSvg;\n}\nfunction lean_right(parent, bbox, node) {\n  const w = bbox.width;\n  const h = bbox.height;\n  const points = [{\n    x: -2 * h / 6,\n    y: 0\n  }, {\n    x: w - h / 6,\n    y: 0\n  }, {\n    x: w + 2 * h / 6,\n    y: -h\n  }, {\n    x: h / 6,\n    y: -h\n  }];\n  const shapeSvg = insertPolygonShape(parent, w, h, points);\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n  return shapeSvg;\n}\nfunction lean_left(parent, bbox, node) {\n  const w = bbox.width;\n  const h = bbox.height;\n  const points = [{\n    x: 2 * h / 6,\n    y: 0\n  }, {\n    x: w + h / 6,\n    y: 0\n  }, {\n    x: w - 2 * h / 6,\n    y: -h\n  }, {\n    x: -h / 6,\n    y: -h\n  }];\n  const shapeSvg = insertPolygonShape(parent, w, h, points);\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n  return shapeSvg;\n}\nfunction trapezoid(parent, bbox, node) {\n  const w = bbox.width;\n  const h = bbox.height;\n  const points = [{\n    x: -2 * h / 6,\n    y: 0\n  }, {\n    x: w + 2 * h / 6,\n    y: 0\n  }, {\n    x: w - h / 6,\n    y: -h\n  }, {\n    x: h / 6,\n    y: -h\n  }];\n  const shapeSvg = insertPolygonShape(parent, w, h, points);\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n  return shapeSvg;\n}\nfunction inv_trapezoid(parent, bbox, node) {\n  const w = bbox.width;\n  const h = bbox.height;\n  const points = [{\n    x: h / 6,\n    y: 0\n  }, {\n    x: w - h / 6,\n    y: 0\n  }, {\n    x: w + 2 * h / 6,\n    y: -h\n  }, {\n    x: -2 * h / 6,\n    y: -h\n  }];\n  const shapeSvg = insertPolygonShape(parent, w, h, points);\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n  return shapeSvg;\n}\nfunction rect_right_inv_arrow(parent, bbox, node) {\n  const w = bbox.width;\n  const h = bbox.height;\n  const points = [{\n    x: 0,\n    y: 0\n  }, {\n    x: w + h / 2,\n    y: 0\n  }, {\n    x: w,\n    y: -h / 2\n  }, {\n    x: w + h / 2,\n    y: -h\n  }, {\n    x: 0,\n    y: -h\n  }];\n  const shapeSvg = insertPolygonShape(parent, w, h, points);\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n  return shapeSvg;\n}\nfunction stadium(parent, bbox, node) {\n  const h = bbox.height;\n  const w = bbox.width + h / 4;\n  const shapeSvg = parent.insert(\"rect\", \":first-child\").attr(\"rx\", h / 2).attr(\"ry\", h / 2).attr(\"x\", -w / 2).attr(\"y\", -h / 2).attr(\"width\", w).attr(\"height\", h);\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n}\nfunction subroutine(parent, bbox, node) {\n  const w = bbox.width;\n  const h = bbox.height;\n  const points = [{\n    x: 0,\n    y: 0\n  }, {\n    x: w,\n    y: 0\n  }, {\n    x: w,\n    y: -h\n  }, {\n    x: 0,\n    y: -h\n  }, {\n    x: 0,\n    y: 0\n  }, {\n    x: -8,\n    y: 0\n  }, {\n    x: w + 8,\n    y: 0\n  }, {\n    x: w + 8,\n    y: -h\n  }, {\n    x: -8,\n    y: -h\n  }, {\n    x: -8,\n    y: 0\n  }];\n  const shapeSvg = insertPolygonShape(parent, w, h, points);\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n  return shapeSvg;\n}\nfunction cylinder(parent, bbox, node) {\n  const w = bbox.width;\n  const rx = w / 2;\n  const ry = rx / (2.5 + w / 50);\n  const h = bbox.height + ry;\n  const shape = \"M 0,\" + ry + \" a \" + rx + \",\" + ry + \" 0,0,0 \" + w + \" 0 a \" + rx + \",\" + ry + \" 0,0,0 \" + -w + \" 0 l 0,\" + h + \" a \" + rx + \",\" + ry + \" 0,0,0 \" + w + \" 0 l 0,\" + -h;\n  const shapeSvg = parent.attr(\"label-offset-y\", ry).insert(\"path\", \":first-child\").attr(\"d\", shape).attr(\"transform\", \"translate(\" + -w / 2 + \",\" + -(h / 2 + ry) + \")\");\n  node.intersect = function (point) {\n    const pos = intersectRect(node, point);\n    const x = pos.x - node.x;\n    if (rx != 0 && (Math.abs(x) < node.width / 2 || Math.abs(x) == node.width / 2 && Math.abs(pos.y - node.y) > node.height / 2 - ry)) {\n      let y = ry * ry * (1 - x * x / (rx * rx));\n      if (y != 0) {\n        y = Math.sqrt(y);\n      }\n      y = ry - y;\n      if (point.y - node.y > 0) {\n        y = -y;\n      }\n      pos.y += y;\n    }\n    return pos;\n  };\n  return shapeSvg;\n}\nfunction addToRender(render2) {\n  render2.shapes().question = question;\n  render2.shapes().hexagon = hexagon;\n  render2.shapes().stadium = stadium;\n  render2.shapes().subroutine = subroutine;\n  render2.shapes().cylinder = cylinder;\n  render2.shapes().rect_left_inv_arrow = rect_left_inv_arrow;\n  render2.shapes().lean_right = lean_right;\n  render2.shapes().lean_left = lean_left;\n  render2.shapes().trapezoid = trapezoid;\n  render2.shapes().inv_trapezoid = inv_trapezoid;\n  render2.shapes().rect_right_inv_arrow = rect_right_inv_arrow;\n}\nfunction addToRenderV2(addShape) {\n  addShape({\n    question\n  });\n  addShape({\n    hexagon\n  });\n  addShape({\n    stadium\n  });\n  addShape({\n    subroutine\n  });\n  addShape({\n    cylinder\n  });\n  addShape({\n    rect_left_inv_arrow\n  });\n  addShape({\n    lean_right\n  });\n  addShape({\n    lean_left\n  });\n  addShape({\n    trapezoid\n  });\n  addShape({\n    inv_trapezoid\n  });\n  addShape({\n    rect_right_inv_arrow\n  });\n}\nfunction insertPolygonShape(parent, w, h, points) {\n  return parent.insert(\"polygon\", \":first-child\").attr(\"points\", points.map(function (d) {\n    return d.x + \",\" + d.y;\n  }).join(\" \")).attr(\"transform\", \"translate(\" + -w / 2 + \",\" + h / 2 + \")\");\n}\nconst flowChartShapes = {\n  addToRender,\n  addToRenderV2\n};\nconst conf = {};\nconst setConf = function (cnf) {\n  const keys = Object.keys(cnf);\n  for (const key of keys) {\n    conf[key] = cnf[key];\n  }\n};\nconst addVertices = function (vert, g, svgId, root, _doc, diagObj) {\n  const svg = !root ? select(\"[id=\\\"\".concat(svgId, \"\\\"]\")) : root.select(\"[id=\\\"\".concat(svgId, \"\\\"]\"));\n  const doc = !_doc ? document : _doc;\n  const keys = Object.keys(vert);\n  keys.forEach(function (id) {\n    const vertex = vert[id];\n    let classStr = \"default\";\n    if (vertex.classes.length > 0) {\n      classStr = vertex.classes.join(\" \");\n    }\n    const styles = getStylesFromArray(vertex.styles);\n    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;\n    let vertexNode;\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      const node = {\n        label: vertexText.replace(/fa[blrs]?:fa-[\\w-]+/g, s => \"<i class='\".concat(s.replace(\":\", \" \"), \"'></i>\"))\n      };\n      vertexNode = addHtmlLabel(svg, node).node();\n      vertexNode.parentNode.removeChild(vertexNode);\n    } else {\n      const svgLabel = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      svgLabel.setAttribute(\"style\", styles.labelStyle.replace(\"color:\", \"fill:\"));\n      const rows = vertexText.split(common.lineBreakRegex);\n      for (const row of rows) {\n        const tspan = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n        tspan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n        tspan.setAttribute(\"dy\", \"1em\");\n        tspan.setAttribute(\"x\", \"1\");\n        tspan.textContent = row;\n        svgLabel.appendChild(tspan);\n      }\n      vertexNode = svgLabel;\n    }\n    let radious = 0;\n    let _shape = \"\";\n    switch (vertex.type) {\n      case \"round\":\n        radious = 5;\n        _shape = \"rect\";\n        break;\n      case \"square\":\n        _shape = \"rect\";\n        break;\n      case \"diamond\":\n        _shape = \"question\";\n        break;\n      case \"hexagon\":\n        _shape = \"hexagon\";\n        break;\n      case \"odd\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n      case \"lean_right\":\n        _shape = \"lean_right\";\n        break;\n      case \"lean_left\":\n        _shape = \"lean_left\";\n        break;\n      case \"trapezoid\":\n        _shape = \"trapezoid\";\n        break;\n      case \"inv_trapezoid\":\n        _shape = \"inv_trapezoid\";\n        break;\n      case \"odd_right\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n      case \"circle\":\n        _shape = \"circle\";\n        break;\n      case \"ellipse\":\n        _shape = \"ellipse\";\n        break;\n      case \"stadium\":\n        _shape = \"stadium\";\n        break;\n      case \"subroutine\":\n        _shape = \"subroutine\";\n        break;\n      case \"cylinder\":\n        _shape = \"cylinder\";\n        break;\n      case \"group\":\n        _shape = \"rect\";\n        break;\n      default:\n        _shape = \"rect\";\n    }\n    log.warn(\"Adding node\", vertex.id, vertex.domId);\n    g.setNode(diagObj.db.lookUpDomId(vertex.id), {\n      labelType: \"svg\",\n      labelStyle: styles.labelStyle,\n      shape: _shape,\n      label: vertexNode,\n      rx: radious,\n      ry: radious,\n      class: classStr,\n      style: styles.style,\n      id: diagObj.db.lookUpDomId(vertex.id)\n    });\n  });\n};\nconst addEdges = function (edges, g, diagObj) {\n  let cnt = 0;\n  let defaultStyle;\n  let defaultLabelStyle;\n  if (edges.defaultStyle !== void 0) {\n    const defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n  edges.forEach(function (edge) {\n    cnt++;\n    const linkId = \"L-\" + edge.start + \"-\" + edge.end;\n    const linkNameStart = \"LS-\" + edge.start;\n    const linkNameEnd = \"LE-\" + edge.end;\n    const edgeData = {};\n    if (edge.type === \"arrow_open\") {\n      edgeData.arrowhead = \"none\";\n    } else {\n      edgeData.arrowhead = \"normal\";\n    }\n    let style = \"\";\n    let labelStyle = \"\";\n    if (edge.style !== void 0) {\n      const styles = getStylesFromArray(edge.style);\n      style = styles.style;\n      labelStyle = styles.labelStyle;\n    } else {\n      switch (edge.stroke) {\n        case \"normal\":\n          style = \"fill:none\";\n          if (defaultStyle !== void 0) {\n            style = defaultStyle;\n          }\n          if (defaultLabelStyle !== void 0) {\n            labelStyle = defaultLabelStyle;\n          }\n          break;\n        case \"dotted\":\n          style = \"fill:none;stroke-width:2px;stroke-dasharray:3;\";\n          break;\n        case \"thick\":\n          style = \" stroke-width: 3.5px;fill:none\";\n          break;\n      }\n    }\n    edgeData.style = style;\n    edgeData.labelStyle = labelStyle;\n    if (edge.interpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n    if (edge.text === void 0) {\n      if (edge.style !== void 0) {\n        edgeData.arrowheadStyle = \"fill: #333\";\n      }\n    } else {\n      edgeData.arrowheadStyle = \"fill: #333\";\n      edgeData.labelpos = \"c\";\n      if (evaluate(getConfig().flowchart.htmlLabels)) {\n        edgeData.labelType = \"html\";\n        edgeData.label = \"<span id=\\\"L-\".concat(linkId, \"\\\" class=\\\"edgeLabel L-\").concat(linkNameStart, \"' L-\").concat(linkNameEnd, \"\\\" style=\\\"\").concat(edgeData.labelStyle, \"\\\">\").concat(edge.text.replace(/fa[blrs]?:fa-[\\w-]+/g, s => \"<i class='\".concat(s.replace(\":\", \" \"), \"'></i>\")), \"</span>\");\n      } else {\n        edgeData.labelType = \"text\";\n        edgeData.label = edge.text.replace(common.lineBreakRegex, \"\\n\");\n        if (edge.style === void 0) {\n          edgeData.style = edgeData.style || \"stroke: #333; stroke-width: 1.5px;fill:none\";\n        }\n        edgeData.labelStyle = edgeData.labelStyle.replace(\"color:\", \"fill:\");\n      }\n    }\n    edgeData.id = linkId;\n    edgeData.class = linkNameStart + \" \" + linkNameEnd;\n    edgeData.minlen = edge.length || 1;\n    g.setEdge(diagObj.db.lookUpDomId(edge.start), diagObj.db.lookUpDomId(edge.end), edgeData, cnt);\n  });\n};\nconst getClasses = function (text, diagObj) {\n  log.info(\"Extracting classes\");\n  return diagObj.db.getClasses();\n};\nconst draw = function (text, id, _version, diagObj) {\n  log.info(\"Drawing flowchart\");\n  const {\n    securityLevel,\n    flowchart: conf2\n  } = getConfig();\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  const doc = securityLevel === \"sandbox\" ? sandboxElement.nodes()[0].contentDocument : document;\n  let dir = diagObj.db.getDirection();\n  if (dir === void 0) {\n    dir = \"TD\";\n  }\n  const nodeSpacing = conf2.nodeSpacing || 50;\n  const rankSpacing = conf2.rankSpacing || 50;\n  const g = new graphlib.Graph({\n    multigraph: true,\n    compound: true\n  }).setGraph({\n    rankdir: dir,\n    nodesep: nodeSpacing,\n    ranksep: rankSpacing,\n    marginx: 8,\n    marginy: 8\n  }).setDefaultEdgeLabel(function () {\n    return {};\n  });\n  let subG;\n  const subGraphs = diagObj.db.getSubGraphs();\n  for (let i2 = subGraphs.length - 1; i2 >= 0; i2--) {\n    subG = subGraphs[i2];\n    diagObj.db.addVertex(subG.id, subG.title, \"group\", void 0, subG.classes);\n  }\n  const vert = diagObj.db.getVertices();\n  log.warn(\"Get vertices\", vert);\n  const edges = diagObj.db.getEdges();\n  let i = 0;\n  for (i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    selectAll(\"cluster\").append(\"text\");\n    for (let j = 0; j < subG.nodes.length; j++) {\n      log.warn(\"Setting subgraph\", subG.nodes[j], diagObj.db.lookUpDomId(subG.nodes[j]), diagObj.db.lookUpDomId(subG.id));\n      g.setParent(diagObj.db.lookUpDomId(subG.nodes[j]), diagObj.db.lookUpDomId(subG.id));\n    }\n  }\n  addVertices(vert, g, id, root, doc, diagObj);\n  addEdges(edges, g, diagObj);\n  const render$1 = new render();\n  flowChartShapes.addToRender(render$1);\n  render$1.arrows().none = function normal(parent, id2, edge, type) {\n    const marker = parent.append(\"marker\").attr(\"id\", id2).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 9).attr(\"refY\", 5).attr(\"markerUnits\", \"strokeWidth\").attr(\"markerWidth\", 8).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\");\n    const path = marker.append(\"path\").attr(\"d\", \"M 0 0 L 0 0 L 0 0 z\");\n    applyStyle(path, edge[type + \"Style\"]);\n  };\n  render$1.arrows().normal = function normal(parent, id2) {\n    const marker = parent.append(\"marker\").attr(\"id\", id2).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 9).attr(\"refY\", 5).attr(\"markerUnits\", \"strokeWidth\").attr(\"markerWidth\", 8).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\");\n    marker.append(\"path\").attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\").attr(\"class\", \"arrowheadPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n  };\n  const svg = root.select(\"[id=\\\"\".concat(id, \"\\\"]\"));\n  const element = root.select(\"#\" + id + \" g\");\n  render$1(element, g);\n  element.selectAll(\"g.node\").attr(\"title\", function () {\n    return diagObj.db.getTooltip(this.id);\n  });\n  diagObj.db.indexNodes(\"subGraph\" + i);\n  for (i = 0; i < subGraphs.length; i++) {\n    subG = subGraphs[i];\n    if (subG.title !== \"undefined\") {\n      const clusterRects = doc.querySelectorAll(\"#\" + id + ' [id=\"' + diagObj.db.lookUpDomId(subG.id) + '\"] rect');\n      const clusterEl = doc.querySelectorAll(\"#\" + id + ' [id=\"' + diagObj.db.lookUpDomId(subG.id) + '\"]');\n      const xPos = clusterRects[0].x.baseVal.value;\n      const yPos = clusterRects[0].y.baseVal.value;\n      const _width = clusterRects[0].width.baseVal.value;\n      const cluster = select(clusterEl[0]);\n      const te = cluster.select(\".label\");\n      te.attr(\"transform\", \"translate(\".concat(xPos + _width / 2, \", \").concat(yPos + 14, \")\"));\n      te.attr(\"id\", id + \"Text\");\n      for (let j = 0; j < subG.classes.length; j++) {\n        clusterEl[0].classList.add(subG.classes[j]);\n      }\n    }\n  }\n  if (!conf2.htmlLabels) {\n    const labels = doc.querySelectorAll('[id=\"' + id + '\"] .edgeLabel .label');\n    for (const label of labels) {\n      const dim = label.getBBox();\n      const rect = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n      rect.setAttribute(\"rx\", 0);\n      rect.setAttribute(\"ry\", 0);\n      rect.setAttribute(\"width\", dim.width);\n      rect.setAttribute(\"height\", dim.height);\n      label.insertBefore(rect, label.firstChild);\n    }\n  }\n  setupGraphViewbox(g, svg, conf2.diagramPadding, conf2.useMaxWidth);\n  const keys = Object.keys(vert);\n  keys.forEach(function (key) {\n    const vertex = vert[key];\n    if (vertex.link) {\n      const node = root.select(\"#\" + id + ' [id=\"' + diagObj.db.lookUpDomId(key) + '\"]');\n      if (node) {\n        const link = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"a\");\n        link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"class\", vertex.classes.join(\" \"));\n        link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"href\", vertex.link);\n        link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"rel\", \"noopener\");\n        if (securityLevel === \"sandbox\") {\n          link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"target\", \"_top\");\n        } else if (vertex.linkTarget) {\n          link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"target\", vertex.linkTarget);\n        }\n        const linkNode = node.insert(function () {\n          return link;\n        }, \":first-child\");\n        const shape = node.select(\".label-container\");\n        if (shape) {\n          linkNode.append(function () {\n            return shape.node();\n          });\n        }\n        const label = node.select(\".label\");\n        if (label) {\n          linkNode.append(function () {\n            return label.node();\n          });\n        }\n      }\n    }\n  });\n};\nconst flowRenderer = {\n  setConf,\n  addVertices,\n  addEdges,\n  getClasses,\n  draw\n};\nconst diagram = {\n  parser,\n  db: flowDb,\n  renderer: flowRendererV2,\n  styles: flowStyles,\n  init: cnf => {\n    if (!cnf.flowchart) {\n      cnf.flowchart = {};\n    }\n    cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;\n    flowRenderer.setConf(cnf.flowchart);\n    flowDb.clear();\n    flowDb.setGen(\"gen-1\");\n  }\n};\nexport { diagram };"],"sourceRoot":""}